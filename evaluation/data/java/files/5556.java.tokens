package io . netty . example . stomp ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . handler . codec . stomp . DefaultStompFrame ; import io . netty . handler . codec . stomp . StompCommand ; import io . netty . handler . codec . stomp . StompFrame ; import io . netty . handler . codec . stomp . StompHeaders ; public class StompClientHandler extends SimpleChannelInboundHandler < StompFrame > { private enum ClientState { AUTHENTICATING , AUTHENTICATED , SUBSCRIBED , DISCONNECTING } private ClientState state ; @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { state = ClientState . AUTHENTICATING ; StompFrame connFrame = new DefaultStompFrame ( StompCommand . CONNECT ) ; connFrame . headers ( ) . set ( StompHeaders . ACCEPT_VERSION , <str> ) ; connFrame . headers ( ) . set ( StompHeaders . HOST , StompClient . HOST ) ; connFrame . headers ( ) . set ( StompHeaders . LOGIN , StompClient . LOGIN ) ; connFrame . headers ( ) . set ( StompHeaders . PASSCODE , StompClient . PASSCODE ) ; ctx . writeAndFlush ( connFrame ) ; } @Override protected void channelRead0 ( ChannelHandlerContext ctx , StompFrame frame ) throws Exception { String subscrReceiptId = <str> ; String disconReceiptId = <str> ; switch ( frame . command ( ) ) { case CONNECTED : StompFrame subscribeFrame = new DefaultStompFrame ( StompCommand . SUBSCRIBE ) ; subscribeFrame . headers ( ) . set ( StompHeaders . DESTINATION , StompClient . TOPIC ) ; subscribeFrame . headers ( ) . set ( StompHeaders . RECEIPT , subscrReceiptId ) ; subscribeFrame . headers ( ) . set ( StompHeaders . ID , <str> ) ; System . out . println ( <str> + subscribeFrame ) ; state = ClientState . AUTHENTICATED ; ctx . writeAndFlush ( subscribeFrame ) ; break ; case RECEIPT : String receiptHeader = frame . headers ( ) . getAsString ( StompHeaders . RECEIPT_ID ) ; if ( state = = ClientState . AUTHENTICATED & & receiptHeader . equals ( subscrReceiptId ) ) { StompFrame msgFrame = new DefaultStompFrame ( StompCommand . SEND ) ; msgFrame . headers ( ) . set ( StompHeaders . DESTINATION , StompClient . TOPIC ) ; msgFrame . content ( ) . writeBytes ( <str> . getBytes ( ) ) ; System . out . println ( <str> + msgFrame ) ; state = ClientState . SUBSCRIBED ; ctx . writeAndFlush ( msgFrame ) ; } else if ( state = = ClientState . DISCONNECTING & & receiptHeader . equals ( disconReceiptId ) ) { System . out . println ( <str> ) ; ctx . close ( ) ; } else { throw new IllegalStateException ( <str> + frame + <str> + state ) ; } break ; case MESSAGE : if ( state = = ClientState . SUBSCRIBED ) { System . out . println ( <str> + frame ) ; StompFrame disconnFrame = new DefaultStompFrame ( StompCommand . DISCONNECT ) ; disconnFrame . headers ( ) . set ( StompHeaders . RECEIPT , disconReceiptId ) ; System . out . println ( <str> + disconnFrame ) ; state = ClientState . DISCONNECTING ; ctx . writeAndFlush ( disconnFrame ) ; } break ; default : break ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { cause . printStackTrace ( ) ; ctx . close ( ) ; } }