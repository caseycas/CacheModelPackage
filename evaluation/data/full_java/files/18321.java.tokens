package com . badlogic . gdx . utils ; import java . util . Comparator ; import java . util . Iterator ; import java . util . NoSuchElementException ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . utils . reflect . ArrayReflection ; public class Array < T > implements Iterable < T > { public T [ ] items ; public int size ; public boolean ordered ; private ArrayIterable iterable ; private Predicate . PredicateIterable < T > predicateIterable ; public Array ( ) { this ( true , <int> ) ; } public Array ( int capacity ) { this ( true , capacity ) ; } public Array ( boolean ordered , int capacity ) { this . ordered = ordered ; items = ( T [ ] ) new Object [ capacity ] ; } public Array ( boolean ordered , int capacity , Class arrayType ) { this . ordered = ordered ; items = ( T [ ] ) ArrayReflection . newInstance ( arrayType , capacity ) ; } public Array ( Class arrayType ) { this ( true , <int> , arrayType ) ; } public Array ( Array < ? extends T > array ) { this ( array . ordered , array . size , array . items . getClass ( ) . getComponentType ( ) ) ; size = array . size ; System . arraycopy ( array . items , <int> , items , <int> , size ) ; } public Array ( T [ ] array ) { this ( true , array , <int> , array . length ) ; } public Array ( boolean ordered , T [ ] array , int start , int count ) { this ( ordered , count , ( Class ) array . getClass ( ) . getComponentType ( ) ) ; size = count ; System . arraycopy ( array , start , items , <int> , size ) ; } public void add ( T value ) { T [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; items [ size + + ] = value ; } public void addAll ( Array < ? extends T > array ) { addAll ( array , <int> , array . size ) ; } public void addAll ( Array < ? extends T > array , int start , int count ) { if ( start + count > array . size ) throw new IllegalArgumentException ( <str> + start + <str> + count + <str> + array . size ) ; addAll ( ( T [ ] ) array . items , start , count ) ; } public void addAll ( T . . . array ) { addAll ( array , <int> , array . length ) ; } public void addAll ( T [ ] array , int start , int count ) { T [ ] items = this . items ; int sizeNeeded = size + count ; if ( sizeNeeded > items . length ) items = resize ( Math . max ( <int> , ( int ) ( sizeNeeded * <float> ) ) ) ; System . arraycopy ( array , start , items , size , count ) ; size + = count ; } public T get ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; return items [ index ] ; } public void set ( int index , T value ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; items [ index ] = value ; } public void insert ( int index , T value ) { if ( index > size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; T [ ] items = this . items ; if ( size = = items . length ) items = resize ( Math . max ( <int> , ( int ) ( size * <float> ) ) ) ; if ( ordered ) System . arraycopy ( items , index , items , index + <int> , size - index ) ; else items [ size ] = items [ index ] ; size + + ; items [ index ] = value ; } public void swap ( int first , int second ) { if ( first > = size ) throw new IndexOutOfBoundsException ( <str> + first + <str> + size ) ; if ( second > = size ) throw new IndexOutOfBoundsException ( <str> + second + <str> + size ) ; T [ ] items = this . items ; T firstValue = items [ first ] ; items [ first ] = items [ second ] ; items [ second ] = firstValue ; } public boolean contains ( T value , boolean identity ) { T [ ] items = this . items ; int i = size - <int> ; if ( identity | | value = = null ) { while ( i > = <int> ) if ( items [ i - - ] = = value ) return true ; } else { while ( i > = <int> ) if ( value . equals ( items [ i - - ] ) ) return true ; } return false ; } public int indexOf ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity | | value = = null ) { for ( int i = <int> , n = size ; i < n ; i + + ) if ( items [ i ] = = value ) return i ; } else { for ( int i = <int> , n = size ; i < n ; i + + ) if ( value . equals ( items [ i ] ) ) return i ; } return - <int> ; } public int lastIndexOf ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity | | value = = null ) { for ( int i = size - <int> ; i > = <int> ; i - - ) if ( items [ i ] = = value ) return i ; } else { for ( int i = size - <int> ; i > = <int> ; i - - ) if ( value . equals ( items [ i ] ) ) return i ; } return - <int> ; } public boolean removeValue ( T value , boolean identity ) { T [ ] items = this . items ; if ( identity | | value = = null ) { for ( int i = <int> , n = size ; i < n ; i + + ) { if ( items [ i ] = = value ) { removeIndex ( i ) ; return true ; } } } else { for ( int i = <int> , n = size ; i < n ; i + + ) { if ( value . equals ( items [ i ] ) ) { removeIndex ( i ) ; return true ; } } } return false ; } public T removeIndex ( int index ) { if ( index > = size ) throw new IndexOutOfBoundsException ( <str> + index + <str> + size ) ; T [ ] items = this . items ; T value = ( T ) items [ index ] ; size - - ; if ( ordered ) System . arraycopy ( items , index + <int> , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; } public void removeRange ( int start , int end ) { if ( end > = size ) throw new IndexOutOfBoundsException ( <str> + end + <str> + size ) ; if ( start > end ) throw new IndexOutOfBoundsException ( <str> + start + <str> + end ) ; T [ ] items = this . items ; int count = end - start + <int> ; if ( ordered ) System . arraycopy ( items , start + count , items , start , size - ( start + count ) ) ; else { int lastIndex = this . size - <int> ; for ( int i = <int> ; i < count ; i + + ) items [ start + i ] = items [ lastIndex - i ] ; } size - = count ; } public boolean removeAll ( Array < ? extends T > array , boolean identity ) { int size = this . size ; int startSize = size ; T [ ] items = this . items ; if ( identity ) { for ( int i = <int> , n = array . size ; i < n ; i + + ) { T item = array . get ( i ) ; for ( int ii = <int> ; ii < size ; ii + + ) { if ( item = = items [ ii ] ) { removeIndex ( ii ) ; size - - ; break ; } } } } else { for ( int i = <int> , n = array . size ; i < n ; i + + ) { T item = array . get ( i ) ; for ( int ii = <int> ; ii < size ; ii + + ) { if ( item . equals ( items [ ii ] ) ) { removeIndex ( ii ) ; size - - ; break ; } } } } return size ! = startSize ; } public T pop ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; - - size ; T item = items [ size ] ; items [ size ] = null ; return item ; } public T peek ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; return items [ size - <int> ] ; } public T first ( ) { if ( size = = <int> ) throw new IllegalStateException ( <str> ) ; return items [ <int> ] ; } public void clear ( ) { T [ ] items = this . items ; for ( int i = <int> , n = size ; i < n ; i + + ) items [ i ] = null ; size = <int> ; } public T [ ] shrink ( ) { if ( items . length ! = size ) resize ( size ) ; return items ; } public T [ ] ensureCapacity ( int additionalCapacity ) { int sizeNeeded = size + additionalCapacity ; if ( sizeNeeded > items . length ) resize ( Math . max ( <int> , sizeNeeded ) ) ; return items ; } protected T [ ] resize ( int newSize ) { T [ ] items = this . items ; T [ ] newItems = ( T [ ] ) ArrayReflection . newInstance ( items . getClass ( ) . getComponentType ( ) , newSize ) ; System . arraycopy ( items , <int> , newItems , <int> , Math . min ( size , newItems . length ) ) ; this . items = newItems ; return newItems ; } public void sort ( ) { Sort . instance ( ) . sort ( items , <int> , size ) ; } public void sort ( Comparator < ? super T > comparator ) { Sort . instance ( ) . sort ( items , comparator , <int> , size ) ; } public T selectRanked ( Comparator < T > comparator , int kthLowest ) { if ( kthLowest < <int> ) { throw new GdxRuntimeException ( <str> ) ; } return Select . instance ( ) . select ( items , comparator , kthLowest , size ) ; } public int selectRankedIndex ( Comparator < T > comparator , int kthLowest ) { if ( kthLowest < <int> ) { throw new GdxRuntimeException ( <str> ) ; } return Select . instance ( ) . selectIndex ( items , comparator , kthLowest , size ) ; } public void reverse ( ) { T [ ] items = this . items ; for ( int i = <int> , lastIndex = size - <int> , n = size / <int> ; i < n ; i + + ) { int ii = lastIndex - i ; T temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public void shuffle ( ) { T [ ] items = this . items ; for ( int i = size - <int> ; i > = <int> ; i - - ) { int ii = MathUtils . random ( i ) ; T temp = items [ i ] ; items [ i ] = items [ ii ] ; items [ ii ] = temp ; } } public Iterator < T > iterator ( ) { if ( iterable = = null ) iterable = new ArrayIterable ( this ) ; return iterable . iterator ( ) ; } public Iterable < T > select ( Predicate < T > predicate ) { if ( predicateIterable = = null ) predicateIterable = new Predicate . PredicateIterable < T > ( this , predicate ) ; else predicateIterable . set ( this , predicate ) ; return predicateIterable ; } public void truncate ( int newSize ) { if ( size < = newSize ) return ; for ( int i = newSize ; i < size ; i + + ) items [ i ] = null ; size = newSize ; } public T random ( ) { if ( size = = <int> ) return null ; return items [ MathUtils . random ( <int> , size - <int> ) ] ; } public T [ ] toArray ( ) { return ( T [ ] ) toArray ( items . getClass ( ) . getComponentType ( ) ) ; } public < V > V [ ] toArray ( Class type ) { V [ ] result = ( V [ ] ) ArrayReflection . newInstance ( type , size ) ; System . arraycopy ( items , <int> , result , <int> , size ) ; return result ; } public int hashCode ( ) { if ( ! ordered ) return super . hashCode ( ) ; Object [ ] items = this . items ; int h = <int> ; for ( int i = <int> , n = size ; i < n ; i + + ) { h * = <int> ; Object item = items [ i ] ; if ( item ! = null ) h + = item . hashCode ( ) ; } return h ; } public boolean equals ( Object object ) { if ( object = = this ) return true ; if ( ! ordered ) return false ; if ( ! ( object instanceof Array ) ) return false ; Array array = ( Array ) object ; if ( ! array . ordered ) return false ; int n = size ; if ( n ! = array . size ) return false ; Object [ ] items1 = this . items ; Object [ ] items2 = array . items ; for ( int i = <int> ; i < n ; i + + ) { Object o1 = items1 [ i ] ; Object o2 = items2 [ i ] ; if ( ! ( o1 = = null ? o2 = = null : o1 . equals ( o2 ) ) ) return false ; } return true ; } public String toString ( ) { if ( size = = <int> ) return <str> ; T [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( <str> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( <str> ) ; buffer . append ( items [ i ] ) ; } buffer . append ( <str> ) ; return buffer . toString ( ) ; } public String toString ( String separator ) { if ( size = = <int> ) return <str> ; T [ ] items = this . items ; StringBuilder buffer = new StringBuilder ( <int> ) ; buffer . append ( items [ <int> ] ) ; for ( int i = <int> ; i < size ; i + + ) { buffer . append ( separator ) ; buffer . append ( items [ i ] ) ; } return buffer . toString ( ) ; } static public < T > Array < T > of ( Class < T > arrayType ) { return new Array < T > ( arrayType ) ; } static public < T > Array < T > of ( boolean ordered , int capacity , Class < T > arrayType ) { return new Array < T > ( ordered , capacity , arrayType ) ; } static public < T > Array < T > with ( T . . . array ) { return new Array ( array ) ; } static public class ArrayIterator < T > implements Iterator < T > , Iterable < T > { private final Array < T > array ; private final boolean allowRemove ; int index ; boolean valid = true ; public ArrayIterator ( Array < T > array ) { this ( array , true ) ; } public ArrayIterator ( Array < T > array , boolean allowRemove ) { this . array = array ; this . allowRemove = allowRemove ; } public boolean hasNext ( ) { if ( ! valid ) { throw new GdxRuntimeException ( <str> ) ; } return index < array . size ; } public T next ( ) { if ( index > = array . size ) throw new NoSuchElementException ( String . valueOf ( index ) ) ; if ( ! valid ) { throw new GdxRuntimeException ( <str> ) ; } return array . items [ index + + ] ; } public void remove ( ) { if ( ! allowRemove ) throw new GdxRuntimeException ( <str> ) ; index - - ; array . removeIndex ( index ) ; } public void reset ( ) { index = <int> ; } public Iterator < T > iterator ( ) { return this ; } } static public class ArrayIterable < T > implements Iterable < T > { private final Array < T > array ; private final boolean allowRemove ; private ArrayIterator iterator1 , iterator2 ; public ArrayIterable ( Array < T > array ) { this ( array , true ) ; } public ArrayIterable ( Array < T > array , boolean allowRemove ) { this . array = array ; this . allowRemove = allowRemove ; } public Iterator < T > iterator ( ) { if ( iterator1 = = null ) { iterator1 = new ArrayIterator ( array , allowRemove ) ; iterator2 = new ArrayIterator ( array , allowRemove ) ; } if ( ! iterator1 . valid ) { iterator1 . index = <int> ; iterator1 . valid = true ; iterator2 . valid = false ; return iterator1 ; } iterator2 . index = <int> ; iterator2 . valid = true ; iterator1 . valid = false ; return iterator2 ; } } } 
