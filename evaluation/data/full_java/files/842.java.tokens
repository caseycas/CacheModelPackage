package org . apache . cassandra . repair ; import java . net . InetAddress ; import java . util . List ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . db . SystemKeyspace ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . streaming . ProgressInfo ; import org . apache . cassandra . streaming . StreamEvent ; import org . apache . cassandra . streaming . StreamEventHandler ; import org . apache . cassandra . streaming . StreamPlan ; import org . apache . cassandra . streaming . StreamState ; import org . apache . cassandra . tracing . TraceState ; import org . apache . cassandra . tracing . Tracing ; import org . apache . cassandra . utils . FBUtilities ; public class LocalSyncTask extends SyncTask implements StreamEventHandler { private final TraceState state = Tracing . instance . get ( ) ; private static final Logger logger = LoggerFactory . getLogger ( LocalSyncTask . class ) ; private final long repairedAt ; public LocalSyncTask ( RepairJobDesc desc , TreeResponse r1 , TreeResponse r2 , long repairedAt ) { super ( desc , r1 , r2 ) ; this . repairedAt = repairedAt ; } protected void startSync ( List < Range < Token > > differences ) { InetAddress local = FBUtilities . getBroadcastAddress ( ) ; InetAddress dst = r2 . endpoint . equals ( local ) ? r1 . endpoint : r2 . endpoint ; InetAddress preferred = SystemKeyspace . getPreferredIP ( dst ) ; String message = String . format ( <str> , differences . size ( ) , dst ) ; logger . info ( <str> , desc . sessionId , message ) ; boolean isIncremental = false ; if ( desc . parentSessionId ! = null ) { ActiveRepairService . ParentRepairSession prs = ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) ; isIncremental = prs . isIncremental ; } Tracing . traceRepair ( message ) ; new StreamPlan ( <str> , repairedAt , <int> , false , isIncremental ) . listeners ( this ) . flushBeforeTransfer ( true ) . requestRanges ( dst , preferred , desc . keyspace , differences , desc . columnFamily ) . transferRanges ( dst , preferred , desc . keyspace , differences , desc . columnFamily ) . execute ( ) ; } public void handleStreamEvent ( StreamEvent event ) { if ( state = = null ) return ; switch ( event . eventType ) { case STREAM_PREPARED : StreamEvent . SessionPreparedEvent spe = ( StreamEvent . SessionPreparedEvent ) event ; state . trace ( <str> , spe . session . peer ) ; break ; case STREAM_COMPLETE : StreamEvent . SessionCompleteEvent sce = ( StreamEvent . SessionCompleteEvent ) event ; state . trace ( <str> , sce . peer , sce . success ? <str> : <str> ) ; break ; case FILE_PROGRESS : ProgressInfo pi = ( ( StreamEvent . ProgressEvent ) event ) . progress ; state . trace ( <str> , new Object [ ] { pi . currentBytes , pi . totalBytes , pi . currentBytes * <int> / pi . totalBytes , pi . direction = = ProgressInfo . Direction . OUT ? <str> : <str> , pi . sessionIndex , pi . peer } ) ; } } public void onSuccess ( StreamState result ) { String message = String . format ( <str> , desc . sessionId , r1 . endpoint , r2 . endpoint , desc . columnFamily ) ; logger . info ( <str> , desc . sessionId , message ) ; Tracing . traceRepair ( message ) ; set ( stat ) ; } public void onFailure ( Throwable t ) { setException ( t ) ; } } 
