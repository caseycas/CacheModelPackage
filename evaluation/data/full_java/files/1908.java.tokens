package clojure . lang ; import java . io . ObjectStreamException ; import java . io . Serializable ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . atomic . AtomicReference ; public class Namespace extends AReference implements Serializable { final public Symbol name ; transient final AtomicReference < IPersistentMap > mappings = new AtomicReference < IPersistentMap > ( ) ; transient final AtomicReference < IPersistentMap > aliases = new AtomicReference < IPersistentMap > ( ) ; final static ConcurrentHashMap < Symbol , Namespace > namespaces = new ConcurrentHashMap < Symbol , Namespace > ( ) ; public String toString ( ) { return name . toString ( ) ; } Namespace ( Symbol name ) { super ( name . meta ( ) ) ; this . name = name ; mappings . set ( RT . DEFAULT_IMPORTS ) ; aliases . set ( RT . map ( ) ) ; } public static ISeq all ( ) { return RT . seq ( namespaces . values ( ) ) ; } public Symbol getName ( ) { return name ; } public IPersistentMap getMappings ( ) { return mappings . get ( ) ; } public Var intern ( Symbol sym ) { if ( sym . ns ! = null ) { throw new IllegalArgumentException ( <str> ) ; } IPersistentMap map = getMappings ( ) ; Object o ; Var v = null ; while ( ( o = map . valAt ( sym ) ) = = null ) { if ( v = = null ) v = new Var ( this , sym ) ; IPersistentMap newMap = map . assoc ( sym , v ) ; mappings . compareAndSet ( map , newMap ) ; map = getMappings ( ) ; } if ( o instanceof Var & & ( ( Var ) o ) . ns = = this ) return ( Var ) o ; if ( v = = null ) v = new Var ( this , sym ) ; warnOrFailOnReplace ( sym , o , v ) ; while ( ! mappings . compareAndSet ( map , map . assoc ( sym , v ) ) ) map = getMappings ( ) ; return v ; } private void warnOrFailOnReplace ( Symbol sym , Object o , Object v ) { if ( o instanceof Var ) { Namespace ns = ( ( Var ) o ) . ns ; if ( ns = = this | | ( v instanceof Var & & ( ( Var ) v ) . ns = = RT . CLOJURE_NS ) ) return ; if ( ns ! = RT . CLOJURE_NS ) throw new IllegalStateException ( sym + <str> + o + <str> + name ) ; } RT . errPrintWriter ( ) . println ( <str> + sym + <str> + o + <str> + name + <str> + v ) ; } Object reference ( Symbol sym , Object val ) { if ( sym . ns ! = null ) { throw new IllegalArgumentException ( <str> ) ; } IPersistentMap map = getMappings ( ) ; Object o ; while ( ( o = map . valAt ( sym ) ) = = null ) { IPersistentMap newMap = map . assoc ( sym , val ) ; mappings . compareAndSet ( map , newMap ) ; map = getMappings ( ) ; } if ( o = = val ) return o ; warnOrFailOnReplace ( sym , o , val ) ; while ( ! mappings . compareAndSet ( map , map . assoc ( sym , val ) ) ) map = getMappings ( ) ; return val ; } public static boolean areDifferentInstancesOfSameClassName ( Class cls1 , Class cls2 ) { return ( cls1 ! = cls2 ) & & ( cls1 . getName ( ) . equals ( cls2 . getName ( ) ) ) ; } Class referenceClass ( Symbol sym , Class val ) { if ( sym . ns ! = null ) { throw new IllegalArgumentException ( <str> ) ; } IPersistentMap map = getMappings ( ) ; Class c = ( Class ) map . valAt ( sym ) ; while ( ( c = = null ) | | ( areDifferentInstancesOfSameClassName ( c , val ) ) ) { IPersistentMap newMap = map . assoc ( sym , val ) ; mappings . compareAndSet ( map , newMap ) ; map = getMappings ( ) ; c = ( Class ) map . valAt ( sym ) ; } if ( c = = val ) return c ; throw new IllegalStateException ( sym + <str> + c + <str> + name ) ; } public void unmap ( Symbol sym ) { if ( sym . ns ! = null ) { throw new IllegalArgumentException ( <str> ) ; } IPersistentMap map = getMappings ( ) ; while ( map . containsKey ( sym ) ) { IPersistentMap newMap = map . without ( sym ) ; mappings . compareAndSet ( map , newMap ) ; map = getMappings ( ) ; } } public Class importClass ( Symbol sym , Class c ) { return referenceClass ( sym , c ) ; } public Class importClass ( Class c ) { String n = c . getName ( ) ; return importClass ( Symbol . intern ( n . substring ( n . lastIndexOf ( <str> ) + <int> ) ) , c ) ; } public Var refer ( Symbol sym , Var var ) { return ( Var ) reference ( sym , var ) ; } public static Namespace findOrCreate ( Symbol name ) { Namespace ns = namespaces . get ( name ) ; if ( ns ! = null ) return ns ; Namespace newns = new Namespace ( name ) ; ns = namespaces . putIfAbsent ( name , newns ) ; return ns = = null ? newns : ns ; } public static Namespace remove ( Symbol name ) { if ( name . equals ( RT . CLOJURE_NS . name ) ) throw new IllegalArgumentException ( <str> ) ; return namespaces . remove ( name ) ; } public static Namespace find ( Symbol name ) { return namespaces . get ( name ) ; } public Object getMapping ( Symbol name ) { return mappings . get ( ) . valAt ( name ) ; } public Var findInternedVar ( Symbol symbol ) { Object o = mappings . get ( ) . valAt ( symbol ) ; if ( o ! = null & & o instanceof Var & & ( ( Var ) o ) . ns = = this ) return ( Var ) o ; return null ; } public IPersistentMap getAliases ( ) { return aliases . get ( ) ; } public Namespace lookupAlias ( Symbol alias ) { IPersistentMap map = getAliases ( ) ; return ( Namespace ) map . valAt ( alias ) ; } public void addAlias ( Symbol alias , Namespace ns ) { if ( alias = = null | | ns = = null ) throw new NullPointerException ( <str> ) ; IPersistentMap map = getAliases ( ) ; while ( ! map . containsKey ( alias ) ) { IPersistentMap newMap = map . assoc ( alias , ns ) ; aliases . compareAndSet ( map , newMap ) ; map = getAliases ( ) ; } if ( ! map . valAt ( alias ) . equals ( ns ) ) throw new IllegalStateException ( <str> + alias + <str> + name + <str> + map . valAt ( alias ) ) ; } public void removeAlias ( Symbol alias ) { IPersistentMap map = getAliases ( ) ; while ( map . containsKey ( alias ) ) { IPersistentMap newMap = map . without ( alias ) ; aliases . compareAndSet ( map , newMap ) ; map = getAliases ( ) ; } } private Object readResolve ( ) throws ObjectStreamException { return findOrCreate ( name ) ; } } 
