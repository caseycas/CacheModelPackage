package com . google . common . math ; import static com . google . common . math . MathBenchmarking . ARRAY_MASK ; import static com . google . common . math . MathBenchmarking . ARRAY_SIZE ; import static com . google . common . math . MathBenchmarking . RANDOM_SOURCE ; import static com . google . common . math . MathBenchmarking . randomExponent ; import static com . google . common . math . MathBenchmarking . randomNonNegativeBigInteger ; import static com . google . common . math . MathBenchmarking . randomPositiveBigInteger ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . common . math . IntMath ; public class IntMathBenchmark { private static int [ ] exponent = new int [ ARRAY_SIZE ] ; private static int [ ] factorial = new int [ ARRAY_SIZE ] ; private static int [ ] binomial = new int [ ARRAY_SIZE ] ; private static final int [ ] positive = new int [ ARRAY_SIZE ] ; private static final int [ ] nonnegative = new int [ ARRAY_SIZE ] ; private static final int [ ] ints = new int [ ARRAY_SIZE ] ; @BeforeExperiment void setUp ( ) { for ( int i = <int> ; i < ARRAY_SIZE ; i + + ) { exponent [ i ] = randomExponent ( ) ; factorial [ i ] = RANDOM_SOURCE . nextInt ( <int> ) ; binomial [ i ] = RANDOM_SOURCE . nextInt ( factorial [ i ] + <int> ) ; positive [ i ] = randomPositiveBigInteger ( Integer . SIZE - <int> ) . intValue ( ) ; nonnegative [ i ] = randomNonNegativeBigInteger ( Integer . SIZE - <int> ) . intValue ( ) ; ints [ i ] = RANDOM_SOURCE . nextInt ( ) ; } } @Benchmark int pow ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = IntMath . pow ( positive [ j ] , exponent [ j ] ) ; } return tmp ; } @Benchmark int mod ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = IntMath . mod ( ints [ j ] , positive [ j ] ) ; } return tmp ; } @Benchmark int gCD ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = IntMath . gcd ( nonnegative [ j ] , positive [ j ] ) ; } return tmp ; } @Benchmark int factorial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = IntMath . factorial ( factorial [ j ] ) ; } return tmp ; } @Benchmark int binomial ( int reps ) { int tmp = <int> ; for ( int i = <int> ; i < reps ; i + + ) { int j = i & ARRAY_MASK ; tmp + = IntMath . binomial ( factorial [ j ] , binomial [ j ] ) ; } return tmp ; } } 
