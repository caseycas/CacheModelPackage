package com . badlogic . gdx . graphics . g3d . utils ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . graphics . GL20 ; public class RenderContext { public final TextureBinder textureBinder ; private boolean blending ; private int blendSFactor ; private int blendDFactor ; private int depthFunc ; private float depthRangeNear ; private float depthRangeFar ; private boolean depthMask ; private int cullFace ; public RenderContext ( TextureBinder textures ) { this . textureBinder = textures ; } public void begin ( ) { Gdx . gl . glDisable ( GL20 . GL_DEPTH_TEST ) ; depthFunc = <int> ; Gdx . gl . glDepthMask ( true ) ; depthMask = true ; Gdx . gl . glDisable ( GL20 . GL_BLEND ) ; blending = false ; Gdx . gl . glDisable ( GL20 . GL_CULL_FACE ) ; cullFace = blendSFactor = blendDFactor = <int> ; textureBinder . begin ( ) ; } public void end ( ) { if ( depthFunc ! = <int> ) Gdx . gl . glDisable ( GL20 . GL_DEPTH_TEST ) ; if ( ! depthMask ) Gdx . gl . glDepthMask ( true ) ; if ( blending ) Gdx . gl . glDisable ( GL20 . GL_BLEND ) ; if ( cullFace > <int> ) Gdx . gl . glDisable ( GL20 . GL_CULL_FACE ) ; textureBinder . end ( ) ; } public void setDepthMask ( final boolean depthMask ) { if ( this . depthMask ! = depthMask ) Gdx . gl . glDepthMask ( this . depthMask = depthMask ) ; } public void setDepthTest ( final int depthFunction ) { setDepthTest ( depthFunction , <float> , <float> ) ; } public void setDepthTest ( final int depthFunction , final float depthRangeNear , final float depthRangeFar ) { final boolean wasEnabled = depthFunc ! = <int> ; final boolean enabled = depthFunction ! = <int> ; if ( depthFunc ! = depthFunction ) { depthFunc = depthFunction ; if ( enabled ) { Gdx . gl . glEnable ( GL20 . GL_DEPTH_TEST ) ; Gdx . gl . glDepthFunc ( depthFunction ) ; } else Gdx . gl . glDisable ( GL20 . GL_DEPTH_TEST ) ; } if ( enabled ) { if ( ! wasEnabled | | depthFunc ! = depthFunction ) Gdx . gl . glDepthFunc ( depthFunc = depthFunction ) ; if ( ! wasEnabled | | this . depthRangeNear ! = depthRangeNear | | this . depthRangeFar ! = depthRangeFar ) Gdx . gl . glDepthRangef ( this . depthRangeNear = depthRangeNear , this . depthRangeFar = depthRangeFar ) ; } } public void setBlending ( final boolean enabled , final int sFactor , final int dFactor ) { if ( enabled ! = blending ) { blending = enabled ; if ( enabled ) Gdx . gl . glEnable ( GL20 . GL_BLEND ) ; else Gdx . gl . glDisable ( GL20 . GL_BLEND ) ; } if ( enabled & & ( blendSFactor ! = sFactor | | blendDFactor ! = dFactor ) ) { Gdx . gl . glBlendFunc ( sFactor , dFactor ) ; blendSFactor = sFactor ; blendDFactor = dFactor ; } } public void setCullFace ( final int face ) { if ( face ! = cullFace ) { cullFace = face ; if ( ( face = = GL20 . GL_FRONT ) | | ( face = = GL20 . GL_BACK ) | | ( face = = GL20 . GL_FRONT_AND_BACK ) ) { Gdx . gl . glEnable ( GL20 . GL_CULL_FACE ) ; Gdx . gl . glCullFace ( face ) ; } else Gdx . gl . glDisable ( GL20 . GL_CULL_FACE ) ; } } } 
