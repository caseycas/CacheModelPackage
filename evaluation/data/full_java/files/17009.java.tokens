package com . badlogic . gwtref . client ; import java . lang . annotation . Annotation ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashSet ; import java . util . Set ; public class Type { private static final Field [ ] EMPTY_FIELDS = new Field [ <int> ] ; private static final Method [ ] EMPTY_METHODS = new Method [ <int> ] ; private static final Constructor [ ] EMPTY_CONSTRUCTORS = new Constructor [ <int> ] ; private static final Annotation [ ] EMPTY_ANNOTATIONS = new Annotation [ <int> ] ; private static final Set < Class > EMPTY_ASSIGNABLES = Collections . unmodifiableSet ( new HashSet < Class > ( ) ) ; private static final Set < Class > EMPTY_INTERFACES = Collections . unmodifiableSet ( new HashSet < Class > ( ) ) ; final String name ; final int id ; final Class clazz ; final CachedTypeLookup superClass ; final Set < Class > assignables ; final Set < Class > interfaces ; boolean isAbstract ; boolean isInterface ; boolean isPrimitive ; boolean isEnum ; boolean isArray ; boolean isMemberClass ; boolean isStatic ; boolean isAnnotation ; Field [ ] fields = EMPTY_FIELDS ; Method [ ] methods = EMPTY_METHODS ; Constructor [ ] constructors = EMPTY_CONSTRUCTORS ; Annotation [ ] annotations = EMPTY_ANNOTATIONS ; Class componentType ; Object [ ] enumConstants ; private Field [ ] allFields ; private Method [ ] allMethods ; public Type ( String name , int id , Class clazz , Class superClass , Set < Class > assignables , Set < Class > interfaces ) { this . name = name ; this . id = id ; this . clazz = clazz ; this . superClass = new CachedTypeLookup ( superClass ) ; this . assignables = assignables ! = null ? assignables : EMPTY_ASSIGNABLES ; this . interfaces = interfaces ! = null ? interfaces : EMPTY_INTERFACES ; } public Object newInstance ( ) throws NoSuchMethodException { return getConstructor ( ) . newInstance ( ) ; } public String getName ( ) { return name ; } public Class getClassOfType ( ) { return clazz ; } public Type getSuperclass ( ) { return superClass . getType ( ) ; } public boolean isAssignableFrom ( Type otherType ) { return clazz = = otherType . clazz | | ( clazz = = Object . class & & ! otherType . isPrimitive ) | | otherType . assignables . contains ( clazz ) ; } public Class [ ] getInterfaces ( ) { return interfaces . toArray ( new Class [ this . interfaces . size ( ) ] ) ; } public Field getField ( String name ) { for ( Field f : getFields ( ) ) { if ( f . name . equals ( name ) ) return f ; } return null ; } public Field [ ] getFields ( ) { if ( allFields = = null ) { ArrayList < Field > allFieldsList = new ArrayList < Field > ( ) ; Type t = this ; while ( t ! = null ) { for ( Field f : t . fields ) { if ( f . isPublic ) allFieldsList . add ( f ) ; } t = t . getSuperclass ( ) ; } allFields = allFieldsList . toArray ( new Field [ allFieldsList . size ( ) ] ) ; } return allFields ; } public Field [ ] getDeclaredFields ( ) { return fields ; } public Method getMethod ( String name , Class . . . parameterTypes ) throws NoSuchMethodException { for ( Method m : getMethods ( ) ) { if ( m . match ( name , parameterTypes ) ) return m ; } throw new NoSuchMethodException ( ) ; } public Method [ ] getMethods ( ) { if ( allMethods = = null ) { ArrayList < Method > allMethodsList = new ArrayList < Method > ( ) ; Type t = this ; while ( t ! = null ) { for ( Method m : t . methods ) { if ( m . isPublic ( ) ) allMethodsList . add ( m ) ; } t = t . getSuperclass ( ) ; } allMethods = allMethodsList . toArray ( new Method [ allMethodsList . size ( ) ] ) ; } return allMethods ; } public Method [ ] getDeclaredMethods ( ) { return methods ; } public Constructor [ ] getConstructors ( ) { return constructors ; } public Constructor getDeclaredConstructor ( Class . . . parameterTypes ) throws NoSuchMethodException { return getConstructor ( parameterTypes ) ; } public Constructor getConstructor ( Class . . . parameterTypes ) throws NoSuchMethodException { for ( Constructor c : constructors ) { if ( c . isPublic ( ) & & c . match ( parameterTypes ) ) return c ; } throw new NoSuchMethodException ( ) ; } public boolean isAbstract ( ) { return isAbstract ; } public boolean isInterface ( ) { return isInterface ; } public boolean isPrimitive ( ) { return isPrimitive ; } public boolean isEnum ( ) { return isEnum ; } public boolean isArray ( ) { return isArray ; } public boolean isMemberClass ( ) { return isMemberClass ; } public boolean isStatic ( ) { return isStatic ; } public boolean isAnnotation ( ) { return isAnnotation ; } public Class getComponentType ( ) { return componentType ; } public int getArrayLength ( Object obj ) { return ReflectionCache . getArrayLength ( this , obj ) ; } public Object getArrayElement ( Object obj , int i ) { return ReflectionCache . getArrayElement ( this , obj , i ) ; } public void setArrayElement ( Object obj , int i , Object value ) { ReflectionCache . setArrayElement ( this , obj , i , value ) ; } public Object [ ] getEnumConstants ( ) { return enumConstants ; } public Annotation [ ] getDeclaredAnnotations ( ) { return annotations ; } public Annotation getDeclaredAnnotation ( Class < ? extends java . lang . annotation . Annotation > annotationType ) { for ( Annotation annotation : annotations ) { if ( annotation . annotationType ( ) . equals ( annotationType ) ) return annotation ; } return null ; } @Override public String toString ( ) { return <str> + name + <str> + clazz + <str> + superClass + <str> + assignables + <str> + isAbstract + <str> + isInterface + <str> + isPrimitive + <str> + isEnum + <str> + isArray + <str> + isMemberClass + <str> + isStatic + <str> + isAnnotation + <str> + Arrays . toString ( fields ) + <str> + Arrays . toString ( methods ) + <str> + Arrays . toString ( constructors ) + <str> + Arrays . toString ( annotations ) + <str> + componentType + <str> + Arrays . toString ( enumConstants ) + <str> ; } } 
