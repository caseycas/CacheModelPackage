package com . nostra13 . universalimageloader . core ; import android . view . View ; import com . nostra13 . universalimageloader . core . assist . FailReason ; import com . nostra13 . universalimageloader . core . assist . FlushedInputStream ; import com . nostra13 . universalimageloader . core . imageaware . ImageAware ; import com . nostra13 . universalimageloader . core . listener . ImageLoadingListener ; import java . io . File ; import java . util . Collections ; import java . util . HashMap ; import java . util . Map ; import java . util . WeakHashMap ; import java . util . concurrent . Executor ; import java . util . concurrent . ExecutorService ; import java . util . concurrent . atomic . AtomicBoolean ; import java . util . concurrent . locks . ReentrantLock ; class ImageLoaderEngine { final ImageLoaderConfiguration configuration ; private Executor taskExecutor ; private Executor taskExecutorForCachedImages ; private Executor taskDistributor ; private final Map < Integer , String > cacheKeysForImageAwares = Collections . synchronizedMap ( new HashMap < Integer , String > ( ) ) ; private final Map < String , ReentrantLock > uriLocks = new WeakHashMap < String , ReentrantLock > ( ) ; private final AtomicBoolean paused = new AtomicBoolean ( false ) ; private final AtomicBoolean networkDenied = new AtomicBoolean ( false ) ; private final AtomicBoolean slowNetwork = new AtomicBoolean ( false ) ; private final Object pauseLock = new Object ( ) ; ImageLoaderEngine ( ImageLoaderConfiguration configuration ) { this . configuration = configuration ; taskExecutor = configuration . taskExecutor ; taskExecutorForCachedImages = configuration . taskExecutorForCachedImages ; taskDistributor = DefaultConfigurationFactory . createTaskDistributor ( ) ; } void submit ( final LoadAndDisplayImageTask task ) { taskDistributor . execute ( new Runnable ( ) { @Override public void run ( ) { File image = configuration . diskCache . get ( task . getLoadingUri ( ) ) ; boolean isImageCachedOnDisk = image ! = null & & image . exists ( ) ; initExecutorsIfNeed ( ) ; if ( isImageCachedOnDisk ) { taskExecutorForCachedImages . execute ( task ) ; } else { taskExecutor . execute ( task ) ; } } } ) ; } void submit ( ProcessAndDisplayImageTask task ) { initExecutorsIfNeed ( ) ; taskExecutorForCachedImages . execute ( task ) ; } private void initExecutorsIfNeed ( ) { if ( ! configuration . customExecutor & & ( ( ExecutorService ) taskExecutor ) . isShutdown ( ) ) { taskExecutor = createTaskExecutor ( ) ; } if ( ! configuration . customExecutorForCachedImages & & ( ( ExecutorService ) taskExecutorForCachedImages ) . isShutdown ( ) ) { taskExecutorForCachedImages = createTaskExecutor ( ) ; } } private Executor createTaskExecutor ( ) { return DefaultConfigurationFactory . createExecutor ( configuration . threadPoolSize , configuration . threadPriority , configuration . tasksProcessingType ) ; } String getLoadingUriForView ( ImageAware imageAware ) { return cacheKeysForImageAwares . get ( imageAware . getId ( ) ) ; } void prepareDisplayTaskFor ( ImageAware imageAware , String memoryCacheKey ) { cacheKeysForImageAwares . put ( imageAware . getId ( ) , memoryCacheKey ) ; } void cancelDisplayTaskFor ( ImageAware imageAware ) { cacheKeysForImageAwares . remove ( imageAware . getId ( ) ) ; } void denyNetworkDownloads ( boolean denyNetworkDownloads ) { networkDenied . set ( denyNetworkDownloads ) ; } void handleSlowNetwork ( boolean handleSlowNetwork ) { slowNetwork . set ( handleSlowNetwork ) ; } void pause ( ) { paused . set ( true ) ; } void resume ( ) { paused . set ( false ) ; synchronized ( pauseLock ) { pauseLock . notifyAll ( ) ; } } void stop ( ) { if ( ! configuration . customExecutor ) { ( ( ExecutorService ) taskExecutor ) . shutdownNow ( ) ; } if ( ! configuration . customExecutorForCachedImages ) { ( ( ExecutorService ) taskExecutorForCachedImages ) . shutdownNow ( ) ; } cacheKeysForImageAwares . clear ( ) ; uriLocks . clear ( ) ; } void fireCallback ( Runnable r ) { taskDistributor . execute ( r ) ; } ReentrantLock getLockForUri ( String uri ) { ReentrantLock lock = uriLocks . get ( uri ) ; if ( lock = = null ) { lock = new ReentrantLock ( ) ; uriLocks . put ( uri , lock ) ; } return lock ; } AtomicBoolean getPause ( ) { return paused ; } Object getPauseLock ( ) { return pauseLock ; } boolean isNetworkDenied ( ) { return networkDenied . get ( ) ; } boolean isSlowNetwork ( ) { return slowNetwork . get ( ) ; } } 
