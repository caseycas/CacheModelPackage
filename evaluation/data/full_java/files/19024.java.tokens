package io . netty . handler . codec . dns ; import io . netty . util . AbstractReferenceCounted ; import io . netty . util . ReferenceCountUtil ; import io . netty . util . ReferenceCounted ; import io . netty . util . ResourceLeak ; import io . netty . util . ResourceLeakDetector ; import io . netty . util . internal . StringUtil ; import java . util . ArrayList ; import java . util . List ; import static io . netty . util . internal . ObjectUtil . checkNotNull ; public abstract class AbstractDnsMessage extends AbstractReferenceCounted implements DnsMessage { private static final ResourceLeakDetector < DnsMessage > leakDetector = new ResourceLeakDetector < DnsMessage > ( DnsMessage . class ) ; private static final int SECTION_QUESTION = DnsSection . QUESTION . ordinal ( ) ; private static final int SECTION_COUNT = <int> ; private final ResourceLeak leak = leakDetector . open ( this ) ; private short id ; private DnsOpCode opCode ; private boolean recursionDesired ; private byte z ; private Object questions ; private Object answers ; private Object authorities ; private Object additionals ; protected AbstractDnsMessage ( int id ) { this ( id , DnsOpCode . QUERY ) ; } protected AbstractDnsMessage ( int id , DnsOpCode opCode ) { setId ( id ) ; setOpCode ( opCode ) ; } @Override public int id ( ) { return id & <hex> ; } @Override public DnsMessage setId ( int id ) { this . id = ( short ) id ; return this ; } @Override public DnsOpCode opCode ( ) { return opCode ; } @Override public DnsMessage setOpCode ( DnsOpCode opCode ) { this . opCode = checkNotNull ( opCode , <str> ) ; return this ; } @Override public boolean isRecursionDesired ( ) { return recursionDesired ; } @Override public DnsMessage setRecursionDesired ( boolean recursionDesired ) { this . recursionDesired = recursionDesired ; return this ; } @Override public int z ( ) { return z ; } @Override public DnsMessage setZ ( int z ) { this . z = ( byte ) ( z & <int> ) ; return this ; } @Override public int count ( DnsSection section ) { return count ( sectionOrdinal ( section ) ) ; } private int count ( int section ) { final Object records = sectionAt ( section ) ; if ( records = = null ) { return <int> ; } if ( records instanceof DnsRecord ) { return <int> ; } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; return recordList . size ( ) ; } @Override public int count ( ) { int count = <int> ; for ( int i = <int> ; i < SECTION_COUNT ; i + + ) { count + = count ( i ) ; } return count ; } @Override public < T extends DnsRecord > T recordAt ( DnsSection section ) { return recordAt ( sectionOrdinal ( section ) ) ; } private < T extends DnsRecord > T recordAt ( int section ) { final Object records = sectionAt ( section ) ; if ( records = = null ) { return null ; } if ( records instanceof DnsRecord ) { return castRecord ( records ) ; } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; if ( recordList . isEmpty ( ) ) { return null ; } return castRecord ( recordList . get ( <int> ) ) ; } @Override public < T extends DnsRecord > T recordAt ( DnsSection section , int index ) { return recordAt ( sectionOrdinal ( section ) , index ) ; } private < T extends DnsRecord > T recordAt ( int section , int index ) { final Object records = sectionAt ( section ) ; if ( records = = null ) { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } if ( records instanceof DnsRecord ) { if ( index = = <int> ) { return castRecord ( records ) ; } else { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; return castRecord ( recordList . get ( index ) ) ; } @Override public DnsMessage setRecord ( DnsSection section , DnsRecord record ) { setRecord ( sectionOrdinal ( section ) , record ) ; return this ; } private void setRecord ( int section , DnsRecord record ) { clear ( section ) ; setSection ( section , checkQuestion ( section , record ) ) ; } @Override public < T extends DnsRecord > T setRecord ( DnsSection section , int index , DnsRecord record ) { return setRecord ( sectionOrdinal ( section ) , index , record ) ; } private < T extends DnsRecord > T setRecord ( int section , int index , DnsRecord record ) { checkQuestion ( section , record ) ; final Object records = sectionAt ( section ) ; if ( records = = null ) { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } if ( records instanceof DnsRecord ) { if ( index = = <int> ) { setSection ( section , record ) ; return castRecord ( records ) ; } else { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; return castRecord ( recordList . set ( index , record ) ) ; } @Override public DnsMessage addRecord ( DnsSection section , DnsRecord record ) { addRecord ( sectionOrdinal ( section ) , record ) ; return this ; } private void addRecord ( int section , DnsRecord record ) { checkQuestion ( section , record ) ; final Object records = sectionAt ( section ) ; if ( records = = null ) { setSection ( section , record ) ; return ; } if ( records instanceof DnsRecord ) { final List < DnsRecord > recordList = newRecordList ( ) ; recordList . add ( castRecord ( records ) ) ; recordList . add ( record ) ; setSection ( section , recordList ) ; return ; } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; recordList . add ( record ) ; } @Override public DnsMessage addRecord ( DnsSection section , int index , DnsRecord record ) { addRecord ( sectionOrdinal ( section ) , index , record ) ; return this ; } private void addRecord ( int section , int index , DnsRecord record ) { checkQuestion ( section , record ) ; final Object records = sectionAt ( section ) ; if ( records = = null ) { if ( index ! = <int> ) { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } setSection ( section , record ) ; return ; } if ( records instanceof DnsRecord ) { final List < DnsRecord > recordList ; if ( index = = <int> ) { recordList = newRecordList ( ) ; recordList . add ( record ) ; recordList . add ( castRecord ( records ) ) ; } else if ( index = = <int> ) { recordList = newRecordList ( ) ; recordList . add ( castRecord ( records ) ) ; recordList . add ( record ) ; } else { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } setSection ( section , recordList ) ; return ; } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; recordList . add ( index , record ) ; } @Override public < T extends DnsRecord > T removeRecord ( DnsSection section , int index ) { return removeRecord ( sectionOrdinal ( section ) , index ) ; } private < T extends DnsRecord > T removeRecord ( int section , int index ) { final Object records = sectionAt ( section ) ; if ( records = = null ) { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } if ( records instanceof DnsRecord ) { if ( index ! = <int> ) { throw new IndexOutOfBoundsException ( <str> + index + <str> ) ; } T record = castRecord ( records ) ; setSection ( section , null ) ; return record ; } @SuppressWarnings ( <str> ) final List < DnsRecord > recordList = ( List < DnsRecord > ) records ; return castRecord ( recordList . remove ( index ) ) ; } @Override public DnsMessage clear ( DnsSection section ) { clear ( sectionOrdinal ( section ) ) ; return this ; } @Override public DnsMessage clear ( ) { for ( int i = <int> ; i < SECTION_COUNT ; i + + ) { clear ( i ) ; } return this ; } private void clear ( int section ) { final Object recordOrList = sectionAt ( section ) ; setSection ( section , null ) ; if ( recordOrList instanceof ReferenceCounted ) { ( ( ReferenceCounted ) recordOrList ) . release ( ) ; } else if ( recordOrList instanceof List ) { @SuppressWarnings ( <str> ) List < DnsRecord > list = ( List < DnsRecord > ) recordOrList ; if ( ! list . isEmpty ( ) ) { for ( Object r : list ) { ReferenceCountUtil . release ( r ) ; } } } } @Override public DnsMessage touch ( ) { return ( DnsMessage ) super . touch ( ) ; } @Override public DnsMessage touch ( Object hint ) { if ( leak ! = null ) { leak . record ( hint ) ; } return this ; } @Override public DnsMessage retain ( ) { return ( DnsMessage ) super . retain ( ) ; } @Override public DnsMessage retain ( int increment ) { return ( DnsMessage ) super . retain ( increment ) ; } @Override protected void deallocate ( ) { clear ( ) ; final ResourceLeak leak = this . leak ; if ( leak ! = null ) { leak . close ( ) ; } } @Override public boolean equals ( Object obj ) { if ( this = = obj ) { return true ; } if ( ! ( obj instanceof DnsMessage ) ) { return false ; } final DnsMessage that = ( DnsMessage ) obj ; if ( id ( ) ! = that . id ( ) ) { return false ; } if ( this instanceof DnsQuery ) { if ( ! ( that instanceof DnsQuery ) ) { return false ; } } else if ( that instanceof DnsQuery ) { return false ; } return true ; } @Override public int hashCode ( ) { return id ( ) * <int> + ( this instanceof DnsQuery ? <int> : <int> ) ; } private Object sectionAt ( int section ) { switch ( section ) { case <int> : return questions ; case <int> : return answers ; case <int> : return authorities ; case <int> : return additionals ; } throw new Error ( ) ; } private void setSection ( int section , Object value ) { switch ( section ) { case <int> : questions = value ; return ; case <int> : answers = value ; return ; case <int> : authorities = value ; return ; case <int> : additionals = value ; return ; } throw new Error ( ) ; } private static int sectionOrdinal ( DnsSection section ) { return checkNotNull ( section , <str> ) . ordinal ( ) ; } private static DnsRecord checkQuestion ( int section , DnsRecord record ) { if ( section = = SECTION_QUESTION & & ! ( checkNotNull ( record , <str> ) instanceof DnsQuestion ) ) { throw new IllegalArgumentException ( <str> + record + <str> + StringUtil . simpleClassName ( DnsQuestion . class ) + <str> ) ; } return record ; } @SuppressWarnings ( <str> ) private static < T extends DnsRecord > T castRecord ( Object record ) { return ( T ) record ; } private static ArrayList < DnsRecord > newRecordList ( ) { return new ArrayList < DnsRecord > ( <int> ) ; } } 
