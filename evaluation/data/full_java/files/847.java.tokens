package org . apache . cassandra . repair ; import java . util . * ; import com . google . common . base . Predicate ; import com . google . common . collect . Sets ; import com . google . common . util . concurrent . ListenableFuture ; import com . google . common . util . concurrent . MoreExecutors ; import org . slf4j . Logger ; import org . slf4j . LoggerFactory ; import org . apache . cassandra . config . Schema ; import org . apache . cassandra . db . ColumnFamilyStore ; import org . apache . cassandra . db . Keyspace ; import org . apache . cassandra . db . compaction . CompactionManager ; import org . apache . cassandra . dht . Bounds ; import org . apache . cassandra . dht . LocalPartitioner ; import org . apache . cassandra . dht . Range ; import org . apache . cassandra . dht . Token ; import org . apache . cassandra . io . sstable . format . SSTableReader ; import org . apache . cassandra . net . IVerbHandler ; import org . apache . cassandra . net . MessageIn ; import org . apache . cassandra . net . MessageOut ; import org . apache . cassandra . net . MessagingService ; import org . apache . cassandra . repair . messages . * ; import org . apache . cassandra . service . ActiveRepairService ; import org . apache . cassandra . utils . Pair ; public class RepairMessageVerbHandler implements IVerbHandler < RepairMessage > { private static final Logger logger = LoggerFactory . getLogger ( RepairMessageVerbHandler . class ) ; public void doVerb ( final MessageIn < RepairMessage > message , final int id ) { RepairJobDesc desc = message . payload . desc ; try { switch ( message . payload . messageType ) { case PREPARE_MESSAGE : PrepareMessage prepareMessage = ( PrepareMessage ) message . payload ; logger . debug ( <str> , prepareMessage ) ; List < ColumnFamilyStore > columnFamilyStores = new ArrayList < > ( prepareMessage . cfIds . size ( ) ) ; for ( UUID cfId : prepareMessage . cfIds ) { Pair < String , String > kscf = Schema . instance . getCF ( cfId ) ; ColumnFamilyStore columnFamilyStore = Keyspace . open ( kscf . left ) . getColumnFamilyStore ( kscf . right ) ; columnFamilyStores . add ( columnFamilyStore ) ; } ActiveRepairService . instance . registerParentRepairSession ( prepareMessage . parentRepairSession , columnFamilyStores , prepareMessage . ranges , prepareMessage . isIncremental , prepareMessage . timestamp , prepareMessage . isGlobal ) ; MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) , id , message . from ) ; break ; case SNAPSHOT : logger . debug ( <str> , desc ) ; ColumnFamilyStore cfs = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; final Collection < Range < Token > > repairingRange = desc . ranges ; Set < SSTableReader > snapshottedSSSTables = cfs . snapshot ( desc . sessionId . toString ( ) , new Predicate < SSTableReader > ( ) { public boolean apply ( SSTableReader sstable ) { return sstable ! = null & & ! sstable . metadata . isIndex ( ) & & new Bounds < > ( sstable . first . getToken ( ) , sstable . last . getToken ( ) ) . intersects ( repairingRange ) ; } } , true ) ; Set < SSTableReader > currentlyRepairing = ActiveRepairService . instance . currentlyRepairing ( cfs . metadata . cfId , desc . parentSessionId ) ; if ( ! Sets . intersection ( currentlyRepairing , snapshottedSSSTables ) . isEmpty ( ) ) { cfs . clearSnapshot ( desc . sessionId . toString ( ) ) ; logger . error ( <str> ) ; MessageOut reply = new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) . withParameter ( MessagingService . FAILURE_RESPONSE_PARAM , MessagingService . ONE_BYTE ) ; MessagingService . instance ( ) . sendReply ( reply , id , message . from ) ; return ; } ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . addSSTables ( cfs . metadata . cfId , snapshottedSSSTables ) ; logger . debug ( <str> , desc . sessionId , message . from ) ; MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) , id , message . from ) ; break ; case VALIDATION_REQUEST : ValidationRequest validationRequest = ( ValidationRequest ) message . payload ; logger . debug ( <str> , validationRequest ) ; ColumnFamilyStore store = Keyspace . open ( desc . keyspace ) . getColumnFamilyStore ( desc . columnFamily ) ; Validator validator = new Validator ( desc , message . from , validationRequest . gcBefore ) ; CompactionManager . instance . submitValidation ( store , validator ) ; break ; case SYNC_REQUEST : SyncRequest request = ( SyncRequest ) message . payload ; logger . debug ( <str> , request ) ; long repairedAt = ActiveRepairService . UNREPAIRED_SSTABLE ; if ( desc . parentSessionId ! = null & & ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) ! = null ) repairedAt = ActiveRepairService . instance . getParentRepairSession ( desc . parentSessionId ) . getRepairedAt ( ) ; StreamingRepairTask task = new StreamingRepairTask ( desc , request , repairedAt ) ; task . run ( ) ; break ; case ANTICOMPACTION_REQUEST : AnticompactionRequest anticompactionRequest = ( AnticompactionRequest ) message . payload ; logger . debug ( <str> , anticompactionRequest ) ; ListenableFuture < ? > compactionDone = ActiveRepairService . instance . doAntiCompaction ( anticompactionRequest . parentRepairSession , anticompactionRequest . successfulRanges ) ; compactionDone . addListener ( new Runnable ( ) { @Override public void run ( ) { MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) , id , message . from ) ; } } , MoreExecutors . sameThreadExecutor ( ) ) ; break ; case CLEANUP : logger . debug ( <str> ) ; CleanupMessage cleanup = ( CleanupMessage ) message . payload ; ActiveRepairService . instance . removeParentRepairSession ( cleanup . parentRepairSession ) ; MessagingService . instance ( ) . sendReply ( new MessageOut ( MessagingService . Verb . INTERNAL_RESPONSE ) , id , message . from ) ; break ; default: ActiveRepairService . instance . handleMessage ( message . from , message . payload ) ; break ; } } catch ( Exception e ) { logger . error ( <str> ) ; if ( desc ! = null & & desc . parentSessionId ! = null ) ActiveRepairService . instance . removeParentRepairSession ( desc . parentSessionId ) ; throw new RuntimeException ( e ) ; } } } 
