package io . netty . example . http . helloworld ; import io . netty . buffer . Unpooled ; import io . netty . channel . ChannelFutureListener ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . ChannelInboundHandlerAdapter ; import io . netty . handler . codec . http . DefaultFullHttpResponse ; import io . netty . handler . codec . http . FullHttpResponse ; import io . netty . handler . codec . http . HttpUtil ; import io . netty . handler . codec . http . HttpRequest ; import io . netty . util . AsciiString ; import static io . netty . handler . codec . http . HttpResponseStatus . * ; import static io . netty . handler . codec . http . HttpVersion . * ; public class HttpHelloWorldServerHandler extends ChannelInboundHandlerAdapter { private static final byte [ ] CONTENT = { <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> } ; private static final AsciiString CONTENT_TYPE = new AsciiString ( <str> ) ; private static final AsciiString CONTENT_LENGTH = new AsciiString ( <str> ) ; private static final AsciiString CONNECTION = new AsciiString ( <str> ) ; private static final AsciiString KEEP_ALIVE = new AsciiString ( <str> ) ; @Override public void channelReadComplete ( ChannelHandlerContext ctx ) { ctx . flush ( ) ; } @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) { if ( msg instanceof HttpRequest ) { HttpRequest req = ( HttpRequest ) msg ; if ( HttpUtil . is100ContinueExpected ( req ) ) { ctx . write ( new DefaultFullHttpResponse ( HTTP_1_1 , CONTINUE ) ) ; } boolean keepAlive = HttpUtil . isKeepAlive ( req ) ; FullHttpResponse response = new DefaultFullHttpResponse ( HTTP_1_1 , OK , Unpooled . wrappedBuffer ( CONTENT ) ) ; response . headers ( ) . set ( CONTENT_TYPE , <str> ) ; response . headers ( ) . setInt ( CONTENT_LENGTH , response . content ( ) . readableBytes ( ) ) ; if ( ! keepAlive ) { ctx . write ( response ) . addListener ( ChannelFutureListener . CLOSE ) ; } else { response . headers ( ) . set ( CONNECTION , KEEP_ALIVE ) ; ctx . write ( response ) ; } } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } } 
