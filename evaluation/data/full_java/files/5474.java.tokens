package org . elasticsearch . action . update ; import org . elasticsearch . action . ActionRequestValidationException ; import org . elasticsearch . action . DocumentRequest ; import org . elasticsearch . action . WriteConsistencyLevel ; import org . elasticsearch . action . index . IndexRequest ; import org . elasticsearch . action . support . single . instance . InstanceShardOperationRequest ; import org . elasticsearch . common . Nullable ; import org . elasticsearch . common . ParseFieldMatcher ; import org . elasticsearch . common . bytes . BytesArray ; import org . elasticsearch . common . bytes . BytesReference ; import org . elasticsearch . common . io . stream . StreamInput ; import org . elasticsearch . common . io . stream . StreamOutput ; import org . elasticsearch . common . lucene . uid . Versions ; import org . elasticsearch . common . xcontent . XContentBuilder ; import org . elasticsearch . common . xcontent . XContentFactory ; import org . elasticsearch . common . xcontent . XContentParser ; import org . elasticsearch . common . xcontent . XContentType ; import org . elasticsearch . index . VersionType ; import org . elasticsearch . script . Script ; import org . elasticsearch . script . ScriptParameterParser ; import org . elasticsearch . script . ScriptParameterParser . ScriptParameterValue ; import org . elasticsearch . script . ScriptService ; import org . elasticsearch . script . ScriptService . ScriptType ; import java . io . IOException ; import java . util . HashMap ; import java . util . List ; import java . util . Map ; import static org . elasticsearch . action . ValidateActions . addValidationError ; public class UpdateRequest extends InstanceShardOperationRequest < UpdateRequest > implements DocumentRequest < UpdateRequest > { private String type ; private String id ; @Nullable private String routing ; @Nullable private String parent ; @Nullable Script script ; private String [ ] fields ; private long version = Versions . MATCH_ANY ; private VersionType versionType = VersionType . INTERNAL ; private int retryOnConflict = <int> ; private boolean refresh = false ; private WriteConsistencyLevel consistencyLevel = WriteConsistencyLevel . DEFAULT ; private IndexRequest upsertRequest ; private boolean scriptedUpsert = false ; private boolean docAsUpsert = false ; private boolean detectNoop = true ; @Nullable private IndexRequest doc ; public UpdateRequest ( ) { } public UpdateRequest ( String index , String type , String id ) { this . index = index ; this . type = type ; this . id = id ; } @Override public ActionRequestValidationException validate ( ) { ActionRequestValidationException validationException = super . validate ( ) ; if ( type = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( id = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( ! ( versionType = = VersionType . INTERNAL | | versionType = = VersionType . FORCE ) ) { validationException = addValidationError ( <str> + versionType + <str> , validationException ) ; } else { if ( version ! = Versions . MATCH_ANY & & retryOnConflict > <int> ) { validationException = addValidationError ( <str> , validationException ) ; } if ( ! versionType . validateVersionForWrites ( version ) ) { validationException = addValidationError ( <str> + version + <str> + versionType . name ( ) + <str> , validationException ) ; } } if ( script = = null & & doc = = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( script ! = null & & doc ! = null ) { validationException = addValidationError ( <str> , validationException ) ; } if ( doc = = null & & docAsUpsert ) { validationException = addValidationError ( <str> , validationException ) ; } return validationException ; } @Override public String type ( ) { return type ; } public UpdateRequest type ( String type ) { this . type = type ; return this ; } @Override public String id ( ) { return id ; } public UpdateRequest id ( String id ) { this . id = id ; return this ; } @Override public UpdateRequest routing ( String routing ) { if ( routing ! = null & & routing . length ( ) = = <int> ) { this . routing = null ; } else { this . routing = routing ; } return this ; } @Override public String routing ( ) { return this . routing ; } public UpdateRequest parent ( String parent ) { this . parent = parent ; if ( routing = = null ) { routing = parent ; } return this ; } public String parent ( ) { return parent ; } int shardId ( ) { return this . shardId ; } public Script script ( ) { return this . script ; } public UpdateRequest script ( Script script ) { this . script = script ; return this ; } @Deprecated public String scriptString ( ) { return this . script = = null ? null : this . script . getScript ( ) ; } @Deprecated public ScriptService . ScriptType scriptType ( ) { return this . script = = null ? null : this . script . getType ( ) ; } @Deprecated public Map < String , Object > scriptParams ( ) { return this . script = = null ? null : this . script . getParams ( ) ; } @Deprecated public UpdateRequest script ( String script , ScriptService . ScriptType scriptType ) { updateOrCreateScript ( script , scriptType , null , null ) ; return this ; } @Deprecated public UpdateRequest script ( String script ) { updateOrCreateScript ( script , ScriptType . INLINE , null , null ) ; return this ; } @Deprecated public UpdateRequest scriptLang ( String scriptLang ) { updateOrCreateScript ( null , null , scriptLang , null ) ; return this ; } @Deprecated public String scriptLang ( ) { return script = = null ? null : script . getLang ( ) ; } @Deprecated public UpdateRequest addScriptParam ( String name , Object value ) { Script script = script ( ) ; if ( script = = null ) { HashMap < String , Object > scriptParams = new HashMap < > ( ) ; scriptParams . put ( name , value ) ; updateOrCreateScript ( null , null , null , scriptParams ) ; } else { Map < String , Object > scriptParams = script . getParams ( ) ; if ( scriptParams = = null ) { scriptParams = new HashMap < > ( ) ; scriptParams . put ( name , value ) ; updateOrCreateScript ( null , null , null , scriptParams ) ; } else { scriptParams . put ( name , value ) ; } } return this ; } @Deprecated public UpdateRequest scriptParams ( Map < String , Object > scriptParams ) { updateOrCreateScript ( null , null , null , scriptParams ) ; return this ; } private void updateOrCreateScript ( String scriptContent , ScriptType type , String lang , Map < String , Object > params ) { Script script = script ( ) ; if ( script = = null ) { script = new Script ( scriptContent = = null ? <str> : scriptContent , type = = null ? ScriptType . INLINE : type , lang , params ) ; } else { String newScriptContent = scriptContent = = null ? script . getScript ( ) : scriptContent ; ScriptType newScriptType = type = = null ? script . getType ( ) : type ; String newScriptLang = lang = = null ? script . getLang ( ) : lang ; Map < String , Object > newScriptParams = params = = null ? script . getParams ( ) : params ; script = new Script ( newScriptContent , newScriptType , newScriptLang , newScriptParams ) ; } script ( script ) ; } @Deprecated public UpdateRequest script ( String script , ScriptService . ScriptType scriptType , @Nullable Map < String , Object > scriptParams ) { this . script = new Script ( script , scriptType , null , scriptParams ) ; return this ; } @Deprecated public UpdateRequest script ( String script , @Nullable String scriptLang , ScriptService . ScriptType scriptType , @Nullable Map < String , Object > scriptParams ) { this . script = new Script ( script , scriptType , scriptLang , scriptParams ) ; return this ; } public UpdateRequest fields ( String . . . fields ) { this . fields = fields ; return this ; } public String [ ] fields ( ) { return this . fields ; } public UpdateRequest retryOnConflict ( int retryOnConflict ) { this . retryOnConflict = retryOnConflict ; return this ; } public int retryOnConflict ( ) { return this . retryOnConflict ; } public UpdateRequest version ( long version ) { this . version = version ; return this ; } public long version ( ) { return this . version ; } public UpdateRequest versionType ( VersionType versionType ) { this . versionType = versionType ; return this ; } public VersionType versionType ( ) { return this . versionType ; } public UpdateRequest refresh ( boolean refresh ) { this . refresh = refresh ; return this ; } public boolean refresh ( ) { return this . refresh ; } public WriteConsistencyLevel consistencyLevel ( ) { return this . consistencyLevel ; } public UpdateRequest consistencyLevel ( WriteConsistencyLevel consistencyLevel ) { this . consistencyLevel = consistencyLevel ; return this ; } public UpdateRequest doc ( IndexRequest doc ) { this . doc = doc ; return this ; } public UpdateRequest doc ( XContentBuilder source ) { safeDoc ( ) . source ( source ) ; return this ; } public UpdateRequest doc ( Map source ) { safeDoc ( ) . source ( source ) ; return this ; } public UpdateRequest doc ( Map source , XContentType contentType ) { safeDoc ( ) . source ( source , contentType ) ; return this ; } public UpdateRequest doc ( String source ) { safeDoc ( ) . source ( source ) ; return this ; } public UpdateRequest doc ( byte [ ] source ) { safeDoc ( ) . source ( source ) ; return this ; } public UpdateRequest doc ( byte [ ] source , int offset , int length ) { safeDoc ( ) . source ( source , offset , length ) ; return this ; } public UpdateRequest doc ( Object . . . source ) { safeDoc ( ) . source ( source ) ; return this ; } public UpdateRequest doc ( String field , Object value ) { safeDoc ( ) . source ( field , value ) ; return this ; } public IndexRequest doc ( ) { return this . doc ; } private IndexRequest safeDoc ( ) { if ( doc = = null ) { doc = new IndexRequest ( ) ; } return doc ; } public UpdateRequest upsert ( IndexRequest upsertRequest ) { this . upsertRequest = upsertRequest ; return this ; } public UpdateRequest upsert ( XContentBuilder source ) { safeUpsertRequest ( ) . source ( source ) ; return this ; } public UpdateRequest upsert ( Map source ) { safeUpsertRequest ( ) . source ( source ) ; return this ; } public UpdateRequest upsert ( Map source , XContentType contentType ) { safeUpsertRequest ( ) . source ( source , contentType ) ; return this ; } public UpdateRequest upsert ( String source ) { safeUpsertRequest ( ) . source ( source ) ; return this ; } public UpdateRequest upsert ( byte [ ] source ) { safeUpsertRequest ( ) . source ( source ) ; return this ; } public UpdateRequest upsert ( byte [ ] source , int offset , int length ) { safeUpsertRequest ( ) . source ( source , offset , length ) ; return this ; } public UpdateRequest upsert ( Object . . . source ) { safeUpsertRequest ( ) . source ( source ) ; return this ; } public IndexRequest upsertRequest ( ) { return this . upsertRequest ; } private IndexRequest safeUpsertRequest ( ) { if ( upsertRequest = = null ) { upsertRequest = new IndexRequest ( ) ; } return upsertRequest ; } public UpdateRequest source ( XContentBuilder source ) throws Exception { return source ( source . bytes ( ) ) ; } public UpdateRequest source ( byte [ ] source ) throws Exception { return source ( source , <int> , source . length ) ; } public UpdateRequest source ( byte [ ] source , int offset , int length ) throws Exception { return source ( new BytesArray ( source , offset , length ) ) ; } public UpdateRequest detectNoop ( boolean detectNoop ) { this . detectNoop = detectNoop ; return this ; } public boolean detectNoop ( ) { return detectNoop ; } public UpdateRequest source ( BytesReference source ) throws Exception { ScriptParameterParser scriptParameterParser = new ScriptParameterParser ( ) ; Map < String , Object > scriptParams = null ; Script script = null ; XContentType xContentType = XContentFactory . xContentType ( source ) ; try ( XContentParser parser = XContentFactory . xContent ( xContentType ) . createParser ( source ) ) { XContentParser . Token token = parser . nextToken ( ) ; if ( token = = null ) { return this ; } String currentFieldName = null ; while ( ( token = parser . nextToken ( ) ) ! = XContentParser . Token . END_OBJECT ) { if ( token = = XContentParser . Token . FIELD_NAME ) { currentFieldName = parser . currentName ( ) ; } else if ( <str> . equals ( currentFieldName ) & & token = = XContentParser . Token . START_OBJECT ) { script = Script . parse ( parser , ParseFieldMatcher . EMPTY ) ; } else if ( <str> . equals ( currentFieldName ) ) { scriptParams = parser . map ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { scriptedUpsert = parser . booleanValue ( ) ; } else if ( <str> . equals ( currentFieldName ) ) { XContentBuilder builder = XContentFactory . contentBuilder ( xContentType ) ; builder . copyCurrentStructure ( parser ) ; safeUpsertRequest ( ) . source ( builder ) ; } else if ( <str> . equals ( currentFieldName ) ) { XContentBuilder docBuilder = XContentFactory . contentBuilder ( xContentType ) ; docBuilder . copyCurrentStructure ( parser ) ; safeDoc ( ) . source ( docBuilder ) ; } else if ( <str> . equals ( currentFieldName ) ) { docAsUpsert ( parser . booleanValue ( ) ) ; } else if ( <str> . equals ( currentFieldName ) ) { detectNoop ( parser . booleanValue ( ) ) ; } else if ( <str> . equals ( currentFieldName ) ) { List < Object > values = parser . list ( ) ; String [ ] fields = values . toArray ( new String [ values . size ( ) ] ) ; fields ( fields ) ; } else { scriptParameterParser . token ( currentFieldName , token , parser , ParseFieldMatcher . EMPTY ) ; } } if ( script = = null ) { ScriptParameterValue scriptValue = scriptParameterParser . getDefaultScriptParameterValue ( ) ; if ( scriptValue ! = null ) { script = new Script ( scriptValue . script ( ) , scriptValue . scriptType ( ) , scriptParameterParser . lang ( ) , scriptParams ) ; } } if ( script ! = null ) { this . script = script ; } } return this ; } public boolean docAsUpsert ( ) { return this . docAsUpsert ; } public UpdateRequest docAsUpsert ( boolean shouldUpsertDoc ) { this . docAsUpsert = shouldUpsertDoc ; return this ; } public boolean scriptedUpsert ( ) { return this . scriptedUpsert ; } public UpdateRequest scriptedUpsert ( boolean scriptedUpsert ) { this . scriptedUpsert = scriptedUpsert ; return this ; } @Override public void readFrom ( StreamInput in ) throws IOException { super . readFrom ( in ) ; consistencyLevel = WriteConsistencyLevel . fromId ( in . readByte ( ) ) ; type = in . readString ( ) ; id = in . readString ( ) ; routing = in . readOptionalString ( ) ; parent = in . readOptionalString ( ) ; if ( in . readBoolean ( ) ) { script = Script . readScript ( in ) ; } retryOnConflict = in . readVInt ( ) ; refresh = in . readBoolean ( ) ; if ( in . readBoolean ( ) ) { doc = new IndexRequest ( ) ; doc . readFrom ( in ) ; } int size = in . readInt ( ) ; if ( size > = <int> ) { fields = new String [ size ] ; for ( int i = <int> ; i < size ; i + + ) { fields [ i ] = in . readString ( ) ; } } if ( in . readBoolean ( ) ) { upsertRequest = new IndexRequest ( ) ; upsertRequest . readFrom ( in ) ; } docAsUpsert = in . readBoolean ( ) ; version = in . readLong ( ) ; versionType = VersionType . fromValue ( in . readByte ( ) ) ; detectNoop = in . readBoolean ( ) ; scriptedUpsert = in . readBoolean ( ) ; } @Override public void writeTo ( StreamOutput out ) throws IOException { super . writeTo ( out ) ; out . writeByte ( consistencyLevel . id ( ) ) ; out . writeString ( type ) ; out . writeString ( id ) ; out . writeOptionalString ( routing ) ; out . writeOptionalString ( parent ) ; boolean hasScript = script ! = null ; out . writeBoolean ( hasScript ) ; if ( hasScript ) { script . writeTo ( out ) ; } out . writeVInt ( retryOnConflict ) ; out . writeBoolean ( refresh ) ; if ( doc = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; doc . index ( index ) ; doc . type ( type ) ; doc . id ( id ) ; doc . writeTo ( out ) ; } if ( fields = = null ) { out . writeInt ( - <int> ) ; } else { out . writeInt ( fields . length ) ; for ( String field : fields ) { out . writeString ( field ) ; } } if ( upsertRequest = = null ) { out . writeBoolean ( false ) ; } else { out . writeBoolean ( true ) ; upsertRequest . index ( index ) ; upsertRequest . type ( type ) ; upsertRequest . id ( id ) ; upsertRequest . writeTo ( out ) ; } out . writeBoolean ( docAsUpsert ) ; out . writeLong ( version ) ; out . writeByte ( versionType . getValue ( ) ) ; out . writeBoolean ( detectNoop ) ; out . writeBoolean ( scriptedUpsert ) ; } } 
