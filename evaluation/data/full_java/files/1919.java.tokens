package clojure . lang ; import java . lang . reflect . InvocationHandler ; import java . lang . reflect . Method ; public class ProxyHandler implements InvocationHandler { final IPersistentMap fns ; public ProxyHandler ( IPersistentMap fns ) { this . fns = fns ; } public Object invoke ( Object proxy , Method method , Object [ ] args ) throws Throwable { Class rt = method . getReturnType ( ) ; IFn fn = ( IFn ) fns . valAt ( method . getName ( ) ) ; if ( fn = = null ) { if ( rt = = Void . TYPE ) return null ; else if ( method . getName ( ) . equals ( <str> ) ) { return proxy = = args [ <int> ] ; } else if ( method . getName ( ) . equals ( <str> ) ) { return System . identityHashCode ( proxy ) ; } else if ( method . getName ( ) . equals ( <str> ) ) { return <str> + System . identityHashCode ( proxy ) ; } throw new UnsupportedOperationException ( ) ; } Object ret = fn . applyTo ( ArraySeq . create ( args ) ) ; if ( rt = = Void . TYPE ) return null ; else if ( rt . isPrimitive ( ) ) { if ( rt = = Character . TYPE ) return ret ; else if ( rt = = Integer . TYPE ) return ( ( Number ) ret ) . intValue ( ) ; else if ( rt = = Long . TYPE ) return ( ( Number ) ret ) . longValue ( ) ; else if ( rt = = Float . TYPE ) return ( ( Number ) ret ) . floatValue ( ) ; else if ( rt = = Double . TYPE ) return ( ( Number ) ret ) . doubleValue ( ) ; else if ( rt = = Boolean . TYPE & & ! ( ret instanceof Boolean ) ) return ret = = null ? Boolean . FALSE : Boolean . TRUE ; else if ( rt = = Byte . TYPE ) return ( byte ) ( ( Number ) ret ) . intValue ( ) ; else if ( rt = = Short . TYPE ) return ( short ) ( ( Number ) ret ) . intValue ( ) ; } return ret ; } } 
