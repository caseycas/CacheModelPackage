package com . badlogic . gdx . backends . lwjgl ; import java . awt . Canvas ; import java . awt . Cursor ; import java . awt . Dimension ; import java . awt . EventQueue ; import java . util . HashMap ; import java . util . Map ; import org . lwjgl . opengl . AWTGLCanvas ; import org . lwjgl . opengl . Display ; import com . badlogic . gdx . Application ; import com . badlogic . gdx . ApplicationListener ; import com . badlogic . gdx . Audio ; import com . badlogic . gdx . Files ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . Graphics ; import com . badlogic . gdx . Input ; import com . badlogic . gdx . LifecycleListener ; import com . badlogic . gdx . Net ; import com . badlogic . gdx . Preferences ; import com . badlogic . gdx . backends . lwjgl . audio . OpenALAudio ; import com . badlogic . gdx . utils . Array ; import com . badlogic . gdx . utils . Clipboard ; import com . badlogic . gdx . utils . SharedLibraryLoader ; public class LwjglCanvas implements Application { static boolean isWindows = System . getProperty ( <str> ) . contains ( <str> ) ; LwjglGraphics graphics ; OpenALAudio audio ; LwjglFiles files ; LwjglInput input ; LwjglNet net ; ApplicationListener listener ; Canvas canvas ; final Array < Runnable > runnables = new Array ( ) ; final Array < Runnable > executedRunnables = new Array ( ) ; final Array < LifecycleListener > lifecycleListeners = new Array < LifecycleListener > ( ) ; boolean running = true ; int logLevel = LOG_INFO ; Cursor cursor ; public LwjglCanvas ( ApplicationListener listener ) { LwjglApplicationConfiguration config = new LwjglApplicationConfiguration ( ) ; initialize ( listener , config ) ; } public LwjglCanvas ( ApplicationListener listener , LwjglApplicationConfiguration config ) { initialize ( listener , config ) ; } private void initialize ( ApplicationListener listener , LwjglApplicationConfiguration config ) { LwjglNativesLoader . load ( ) ; canvas = new Canvas ( ) { private final Dimension minSize = new Dimension ( <int> , <int> ) ; public final void addNotify ( ) { super . addNotify ( ) ; if ( SharedLibraryLoader . isMac ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { create ( ) ; } } ) ; } else create ( ) ; } public final void removeNotify ( ) { stop ( ) ; super . removeNotify ( ) ; } public Dimension getMinimumSize ( ) { return minSize ; } } ; canvas . setSize ( <int> , <int> ) ; canvas . setIgnoreRepaint ( true ) ; graphics = new LwjglGraphics ( canvas , config ) { public void setTitle ( String title ) { super . setTitle ( title ) ; LwjglCanvas . this . setTitle ( title ) ; } public boolean setDisplayMode ( int width , int height , boolean fullscreen ) { if ( ! super . setDisplayMode ( width , height , fullscreen ) ) return false ; if ( ! fullscreen ) LwjglCanvas . this . setDisplayMode ( width , height ) ; return true ; } public boolean setDisplayMode ( DisplayMode displayMode ) { if ( ! super . setDisplayMode ( displayMode ) ) return false ; LwjglCanvas . this . setDisplayMode ( displayMode . width , displayMode . height ) ; return true ; } } ; graphics . setVSync ( config . vSyncEnabled ) ; if ( ! LwjglApplicationConfiguration . disableAudio ) audio = new OpenALAudio ( ) ; files = new LwjglFiles ( ) ; input = new LwjglInput ( ) ; net = new LwjglNet ( ) ; this . listener = listener ; Gdx . app = this ; Gdx . graphics = graphics ; Gdx . audio = audio ; Gdx . files = files ; Gdx . input = input ; Gdx . net = net ; } protected void setDisplayMode ( int width , int height ) { } protected void setTitle ( String title ) { } @Override public ApplicationListener getApplicationListener ( ) { return listener ; } public Canvas getCanvas ( ) { return canvas ; } @Override public Audio getAudio ( ) { return audio ; } @Override public Files getFiles ( ) { return files ; } @Override public Graphics getGraphics ( ) { return graphics ; } @Override public Input getInput ( ) { return input ; } @Override public Net getNet ( ) { return net ; } @Override public ApplicationType getType ( ) { return ApplicationType . Desktop ; } @Override public int getVersion ( ) { return <int> ; } void create ( ) { try { graphics . setupDisplay ( ) ; listener . create ( ) ; listener . resize ( Math . max ( <int> , graphics . getWidth ( ) ) , Math . max ( <int> , graphics . getHeight ( ) ) ) ; start ( ) ; } catch ( Exception ex ) { stopped ( ) ; exception ( ex ) ; return ; } EventQueue . invokeLater ( new Runnable ( ) { int lastWidth = Math . max ( <int> , graphics . getWidth ( ) ) ; int lastHeight = Math . max ( <int> , graphics . getHeight ( ) ) ; public void run ( ) { if ( ! running | | Display . isCloseRequested ( ) ) { running = false ; stopped ( ) ; return ; } try { Display . processMessages ( ) ; if ( cursor ! = null | | ! isWindows ) canvas . setCursor ( cursor ) ; boolean shouldRender = false ; int width = Math . max ( <int> , graphics . getWidth ( ) ) ; int height = Math . max ( <int> , graphics . getHeight ( ) ) ; if ( lastWidth ! = width | | lastHeight ! = height ) { lastWidth = width ; lastHeight = height ; Gdx . gl . glViewport ( <int> , <int> , lastWidth , lastHeight ) ; resize ( width , height ) ; listener . resize ( width , height ) ; shouldRender = true ; } if ( executeRunnables ( ) ) shouldRender = true ; if ( ! running ) return ; input . update ( ) ; shouldRender | = graphics . shouldRender ( ) ; input . processEvents ( ) ; if ( audio ! = null ) audio . update ( ) ; if ( shouldRender ) { graphics . updateTime ( ) ; graphics . frameId + + ; listener . render ( ) ; Display . update ( false ) ; } Display . sync ( getFrameRate ( ) ) ; } catch ( Throwable ex ) { exception ( ex ) ; } EventQueue . invokeLater ( this ) ; } } ) ; } public boolean executeRunnables ( ) { synchronized ( runnables ) { for ( int i = runnables . size - <int> ; i > = <int> ; i - - ) executedRunnables . addAll ( runnables . get ( i ) ) ; runnables . clear ( ) ; } if ( executedRunnables . size = = <int> ) return false ; do executedRunnables . pop ( ) . run ( ) ; while ( executedRunnables . size > <int> ) ; return true ; } protected int getFrameRate ( ) { int frameRate = Display . isActive ( ) ? graphics . config . foregroundFPS : graphics . config . backgroundFPS ; if ( frameRate = = - <int> ) frameRate = <int> ; if ( frameRate = = <int> ) frameRate = graphics . config . backgroundFPS ; if ( frameRate = = <int> ) frameRate = <int> ; return frameRate ; } protected void exception ( Throwable ex ) { ex . printStackTrace ( ) ; stop ( ) ; } protected void start ( ) { } protected void resize ( int width , int height ) { } protected void stopped ( ) { } public void stop ( ) { EventQueue . invokeLater ( new Runnable ( ) { public void run ( ) { if ( ! running ) return ; running = false ; try { Display . destroy ( ) ; if ( audio ! = null ) audio . dispose ( ) ; } catch ( Throwable ignored ) { } Array < LifecycleListener > listeners = lifecycleListeners ; synchronized ( listeners ) { for ( LifecycleListener listener : listeners ) { listener . pause ( ) ; listener . dispose ( ) ; } } listener . pause ( ) ; listener . dispose ( ) ; } } ) ; } @Override public long getJavaHeap ( ) { return Runtime . getRuntime ( ) . totalMemory ( ) - Runtime . getRuntime ( ) . freeMemory ( ) ; } @Override public long getNativeHeap ( ) { return getJavaHeap ( ) ; } Map < String , Preferences > preferences = new HashMap < String , Preferences > ( ) ; @Override public Preferences getPreferences ( String name ) { if ( preferences . containsKey ( name ) ) { return preferences . get ( name ) ; } else { Preferences prefs = new LwjglPreferences ( name , <str> ) ; preferences . put ( name , prefs ) ; return prefs ; } } @Override public Clipboard getClipboard ( ) { return new LwjglClipboard ( ) ; } @Override public void postRunnable ( Runnable runnable ) { synchronized ( runnables ) { runnables . add ( runnable ) ; Gdx . graphics . requestRendering ( ) ; } } @Override public void debug ( String tag , String message ) { if ( logLevel > = LOG_DEBUG ) { System . out . println ( tag + <str> + message ) ; } } @Override public void debug ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_DEBUG ) { System . out . println ( tag + <str> + message ) ; exception . printStackTrace ( System . out ) ; } } public void log ( String tag , String message ) { if ( logLevel > = LOG_INFO ) { System . out . println ( tag + <str> + message ) ; } } @Override public void log ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_INFO ) { System . out . println ( tag + <str> + message ) ; exception . printStackTrace ( System . out ) ; } } @Override public void error ( String tag , String message ) { if ( logLevel > = LOG_ERROR ) { System . err . println ( tag + <str> + message ) ; } } @Override public void error ( String tag , String message , Throwable exception ) { if ( logLevel > = LOG_ERROR ) { System . err . println ( tag + <str> + message ) ; exception . printStackTrace ( System . err ) ; } } @Override public void setLogLevel ( int logLevel ) { this . logLevel = logLevel ; } @Override public int getLogLevel ( ) { return logLevel ; } @Override public void exit ( ) { postRunnable ( new Runnable ( ) { @Override public void run ( ) { LwjglCanvas . this . listener . pause ( ) ; LwjglCanvas . this . listener . dispose ( ) ; if ( audio ! = null ) audio . dispose ( ) ; System . exit ( - <int> ) ; } } ) ; } public void setCursor ( Cursor cursor ) { this . cursor = cursor ; } @Override public void addLifecycleListener ( LifecycleListener listener ) { synchronized ( lifecycleListeners ) { lifecycleListeners . add ( listener ) ; } } @Override public void removeLifecycleListener ( LifecycleListener listener ) { synchronized ( lifecycleListeners ) { lifecycleListeners . removeValue ( listener , true ) ; } } } 
