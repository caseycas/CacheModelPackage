package io . netty . microbench . buffer ; import io . netty . buffer . ByteBuf ; import io . netty . buffer . ByteBufAllocator ; import io . netty . buffer . PooledByteBufAllocator ; import io . netty . buffer . UnpooledByteBufAllocator ; import io . netty . microbench . util . AbstractMicrobenchmark ; import org . openjdk . jmh . annotations . Benchmark ; import org . openjdk . jmh . annotations . Param ; import org . openjdk . jmh . annotations . Scope ; import org . openjdk . jmh . annotations . State ; import java . util . Random ; @State ( Scope . Benchmark ) public class ByteBufAllocatorBenchmark extends AbstractMicrobenchmark { private static final ByteBufAllocator unpooledAllocator = new UnpooledByteBufAllocator ( true ) ; private static final ByteBufAllocator pooledAllocator = new PooledByteBufAllocator ( true , <int> , <int> , <int> , <int> , <int> , <int> , <int> ) ; private static final int MAX_LIVE_BUFFERS = <int> ; private static final Random rand = new Random ( ) ; private static final ByteBuf [ ] unpooledHeapBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; private static final ByteBuf [ ] unpooledDirectBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; private static final ByteBuf [ ] pooledHeapBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; private static final ByteBuf [ ] pooledDirectBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; private static final ByteBuf [ ] defaultPooledHeapBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; private static final ByteBuf [ ] defaultPooledDirectBuffers = new ByteBuf [ MAX_LIVE_BUFFERS ] ; @Param ( { <str> , <str> , <str> , <str> , <str> , <str> } ) public int size ; @Benchmark public void unpooledHeapAllocAndFree ( ) { int idx = rand . nextInt ( unpooledHeapBuffers . length ) ; ByteBuf oldBuf = unpooledHeapBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } unpooledHeapBuffers [ idx ] = unpooledAllocator . heapBuffer ( size ) ; } @Benchmark public void unpooledDirectAllocAndFree ( ) { int idx = rand . nextInt ( unpooledDirectBuffers . length ) ; ByteBuf oldBuf = unpooledDirectBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } unpooledDirectBuffers [ idx ] = unpooledAllocator . directBuffer ( size ) ; } @Benchmark public void pooledHeapAllocAndFree ( ) { int idx = rand . nextInt ( pooledHeapBuffers . length ) ; ByteBuf oldBuf = pooledHeapBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } pooledHeapBuffers [ idx ] = pooledAllocator . heapBuffer ( size ) ; } @Benchmark public void pooledDirectAllocAndFree ( ) { int idx = rand . nextInt ( pooledDirectBuffers . length ) ; ByteBuf oldBuf = pooledDirectBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } pooledDirectBuffers [ idx ] = pooledAllocator . directBuffer ( size ) ; } @Benchmark public void defaultPooledHeapAllocAndFree ( ) { int idx = rand . nextInt ( defaultPooledHeapBuffers . length ) ; ByteBuf oldBuf = defaultPooledHeapBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } defaultPooledHeapBuffers [ idx ] = PooledByteBufAllocator . DEFAULT . heapBuffer ( size ) ; } @Benchmark public void defaultPooledDirectAllocAndFree ( ) { int idx = rand . nextInt ( defaultPooledDirectBuffers . length ) ; ByteBuf oldBuf = defaultPooledDirectBuffers [ idx ] ; if ( oldBuf ! = null ) { oldBuf . release ( ) ; } defaultPooledDirectBuffers [ idx ] = PooledByteBufAllocator . DEFAULT . directBuffer ( size ) ; } } 
