package org . apache . cassandra . service . pager ; import org . apache . cassandra . utils . AbstractIterator ; import org . apache . cassandra . db . * ; import org . apache . cassandra . db . rows . * ; import org . apache . cassandra . db . filter . DataLimits ; import org . apache . cassandra . db . partitions . * ; import org . apache . cassandra . exceptions . RequestValidationException ; import org . apache . cassandra . exceptions . RequestExecutionException ; import org . apache . cassandra . service . ClientState ; public class MultiPartitionPager implements QueryPager { private final SinglePartitionPager [ ] pagers ; private final DataLimits limit ; private final int nowInSec ; private int remaining ; private int current ; public MultiPartitionPager ( SinglePartitionReadCommand . Group group , PagingState state , int protocolVersion ) { this . limit = group . limits ( ) ; this . nowInSec = group . nowInSec ( ) ; int i = <int> ; if ( state ! = null ) for ( ; i < group . commands . size ( ) ; i + + ) if ( group . commands . get ( i ) . partitionKey ( ) . getKey ( ) . equals ( state . partitionKey ) ) break ; if ( i > = group . commands . size ( ) ) { pagers = null ; return ; } pagers = new SinglePartitionPager [ group . commands . size ( ) - i ] ; pagers [ <int> ] = group . commands . get ( i ) . getPager ( state , protocolVersion ) ; for ( int j = i + <int> ; j < group . commands . size ( ) ; j + + ) pagers [ j - i ] = group . commands . get ( j ) . getPager ( null , protocolVersion ) ; remaining = state = = null ? limit . count ( ) : state . remaining ; } public PagingState state ( ) { if ( isExhausted ( ) ) return null ; PagingState state = pagers [ current ] . state ( ) ; return new PagingState ( pagers [ current ] . key ( ) , state = = null ? null : state . rowMark , remaining , Integer . MAX_VALUE ) ; } public boolean isExhausted ( ) { if ( remaining < = <int> | | pagers = = null ) return true ; while ( current < pagers . length ) { if ( ! pagers [ current ] . isExhausted ( ) ) return false ; current + + ; } return true ; } public ReadExecutionController executionController ( ) { for ( int i = current ; i < pagers . length ; i + + ) { if ( pagers [ i ] ! = null ) return pagers [ i ] . executionController ( ) ; } throw new AssertionError ( <str> ) ; } @SuppressWarnings ( <str> ) public PartitionIterator fetchPage ( int pageSize , ConsistencyLevel consistency , ClientState clientState ) throws RequestValidationException , RequestExecutionException { int toQuery = Math . min ( remaining , pageSize ) ; PagersIterator iter = new PagersIterator ( toQuery , consistency , clientState , null ) ; DataLimits . Counter counter = limit . forPaging ( toQuery ) . newCounter ( nowInSec , true ) ; iter . setCounter ( counter ) ; return counter . applyTo ( iter ) ; } @SuppressWarnings ( <str> ) public PartitionIterator fetchPageInternal ( int pageSize , ReadExecutionController executionController ) throws RequestValidationException , RequestExecutionException { int toQuery = Math . min ( remaining , pageSize ) ; PagersIterator iter = new PagersIterator ( toQuery , null , null , executionController ) ; DataLimits . Counter counter = limit . forPaging ( toQuery ) . newCounter ( nowInSec , true ) ; iter . setCounter ( counter ) ; return counter . applyTo ( iter ) ; } private class PagersIterator extends AbstractIterator < RowIterator > implements PartitionIterator { private final int pageSize ; private PartitionIterator result ; private DataLimits . Counter counter ; private final ConsistencyLevel consistency ; private final ClientState clientState ; private final ReadExecutionController executionController ; public PagersIterator ( int pageSize , ConsistencyLevel consistency , ClientState clientState , ReadExecutionController executionController ) { this . pageSize = pageSize ; this . consistency = consistency ; this . clientState = clientState ; this . executionController = executionController ; } public void setCounter ( DataLimits . Counter counter ) { this . counter = counter ; } protected RowIterator computeNext ( ) { while ( result = = null | | ! result . hasNext ( ) ) { if ( result ! = null ) result . close ( ) ; if ( isExhausted ( ) ) return endOfData ( ) ; int toQuery = pageSize - counter . counted ( ) ; result = consistency = = null ? pagers [ current ] . fetchPageInternal ( toQuery , executionController ) : pagers [ current ] . fetchPage ( toQuery , consistency , clientState ) ; } return result . next ( ) ; } public void close ( ) { remaining - = counter . counted ( ) ; if ( result ! = null ) result . close ( ) ; } } public int maxRemaining ( ) { return remaining ; } } 
