package org . junit . internal . matchers ; import java . lang . reflect . Method ; import org . hamcrest . BaseMatcher ; import org . junit . internal . MethodSorter ; @Deprecated public abstract class TypeSafeMatcher < T > extends BaseMatcher < T > { private Class < ? > expectedType ; public abstract boolean matchesSafely ( T item ) ; protected TypeSafeMatcher ( ) { expectedType = findExpectedType ( getClass ( ) ) ; } private static Class < ? > findExpectedType ( Class < ? > fromClass ) { for ( Class < ? > c = fromClass ; c ! = Object . class ; c = c . getSuperclass ( ) ) { for ( Method method : MethodSorter . getDeclaredMethods ( c ) ) { if ( isMatchesSafelyMethod ( method ) ) { return method . getParameterTypes ( ) [ <int> ] ; } } } throw new Error ( <str> ) ; } private static boolean isMatchesSafelyMethod ( Method method ) { return <str> . equals ( method . getName ( ) ) & & method . getParameterTypes ( ) . length = = <int> & & ! method . isSynthetic ( ) ; } protected TypeSafeMatcher ( Class < T > expectedType ) { this . expectedType = expectedType ; } @SuppressWarnings ( { <str> } ) public final boolean matches ( Object item ) { return item ! = null & & expectedType . isInstance ( item ) & & matchesSafely ( ( T ) item ) ; } } 
