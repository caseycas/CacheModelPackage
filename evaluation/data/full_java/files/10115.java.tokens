package com . google . common . testing ; import static com . google . common . base . Preconditions . checkArgument ; import com . google . common . annotations . Beta ; import com . google . common . base . CharMatcher ; import com . google . common . base . Charsets ; import com . google . common . base . Defaults ; import com . google . common . base . Equivalence ; import com . google . common . base . Joiner ; import com . google . common . base . Optional ; import com . google . common . base . Predicate ; import com . google . common . base . Predicates ; import com . google . common . base . Splitter ; import com . google . common . base . Stopwatch ; import com . google . common . base . Ticker ; import com . google . common . collect . BiMap ; import com . google . common . collect . ClassToInstanceMap ; import com . google . common . collect . ImmutableBiMap ; import com . google . common . collect . ImmutableClassToInstanceMap ; import com . google . common . collect . ImmutableCollection ; import com . google . common . collect . ImmutableList ; import com . google . common . collect . ImmutableListMultimap ; import com . google . common . collect . ImmutableMap ; import com . google . common . collect . ImmutableMultimap ; import com . google . common . collect . ImmutableMultiset ; import com . google . common . collect . ImmutableSet ; import com . google . common . collect . ImmutableSetMultimap ; import com . google . common . collect . ImmutableSortedMap ; import com . google . common . collect . ImmutableSortedMultiset ; import com . google . common . collect . ImmutableSortedSet ; import com . google . common . collect . ImmutableTable ; import com . google . common . collect . Iterators ; import com . google . common . collect . ListMultimap ; import com . google . common . collect . MapConstraint ; import com . google . common . collect . MapConstraints ; import com . google . common . collect . MapDifference ; import com . google . common . collect . Maps ; import com . google . common . collect . Multimap ; import com . google . common . collect . Multimaps ; import com . google . common . collect . Multiset ; import com . google . common . collect . Ordering ; import com . google . common . collect . PeekingIterator ; import com . google . common . collect . Range ; import com . google . common . collect . RowSortedTable ; import com . google . common . collect . SetMultimap ; import com . google . common . collect . Sets ; import com . google . common . collect . SortedMapDifference ; import com . google . common . collect . SortedMultiset ; import com . google . common . collect . SortedSetMultimap ; import com . google . common . collect . Table ; import com . google . common . collect . Tables ; import com . google . common . collect . TreeBasedTable ; import com . google . common . collect . TreeMultimap ; import com . google . common . io . ByteSink ; import com . google . common . io . ByteSource ; import com . google . common . io . ByteStreams ; import com . google . common . io . CharSink ; import com . google . common . io . CharSource ; import com . google . common . primitives . Primitives ; import com . google . common . primitives . UnsignedInteger ; import com . google . common . primitives . UnsignedLong ; import java . io . ByteArrayInputStream ; import java . io . ByteArrayOutputStream ; import java . io . File ; import java . io . InputStream ; import java . io . OutputStream ; import java . io . PrintStream ; import java . io . PrintWriter ; import java . io . Reader ; import java . io . Serializable ; import java . io . StringReader ; import java . io . StringWriter ; import java . io . Writer ; import java . lang . reflect . AnnotatedElement ; import java . lang . reflect . Array ; import java . lang . reflect . Constructor ; import java . lang . reflect . Field ; import java . lang . reflect . GenericDeclaration ; import java . lang . reflect . InvocationTargetException ; import java . lang . reflect . Modifier ; import java . lang . reflect . Type ; import java . math . BigDecimal ; import java . math . BigInteger ; import java . nio . Buffer ; import java . nio . ByteBuffer ; import java . nio . CharBuffer ; import java . nio . DoubleBuffer ; import java . nio . FloatBuffer ; import java . nio . IntBuffer ; import java . nio . LongBuffer ; import java . nio . ShortBuffer ; import java . nio . charset . Charset ; import java . util . ArrayDeque ; import java . util . Arrays ; import java . util . Collection ; import java . util . Comparator ; import java . util . Currency ; import java . util . Deque ; import java . util . Iterator ; import java . util . List ; import java . util . ListIterator ; import java . util . Locale ; import java . util . Map ; import java . util . NavigableMap ; import java . util . NavigableSet ; import java . util . Queue ; import java . util . Random ; import java . util . Set ; import java . util . SortedMap ; import java . util . SortedSet ; import java . util . concurrent . BlockingDeque ; import java . util . concurrent . BlockingQueue ; import java . util . concurrent . ConcurrentHashMap ; import java . util . concurrent . ConcurrentMap ; import java . util . concurrent . ConcurrentNavigableMap ; import java . util . concurrent . ConcurrentSkipListMap ; import java . util . concurrent . CountDownLatch ; import java . util . concurrent . Executor ; import java . util . concurrent . LinkedBlockingDeque ; import java . util . concurrent . ScheduledThreadPoolExecutor ; import java . util . concurrent . ThreadFactory ; import java . util . concurrent . ThreadPoolExecutor ; import java . util . concurrent . TimeUnit ; import java . util . logging . Level ; import java . util . logging . Logger ; import java . util . regex . MatchResult ; import java . util . regex . Matcher ; import java . util . regex . Pattern ; import javax . annotation . Nullable ; @Beta public final class ArbitraryInstances { private static final Ordering < Field > BY_FIELD_NAME = new Ordering < Field > ( ) { @Override public int compare ( Field left , Field right ) { return left . getName ( ) . compareTo ( right . getName ( ) ) ; } } ; private static MatchResult newMatchResult ( ) { Matcher matcher = Pattern . compile ( <str> ) . matcher ( <str> ) ; matcher . find ( ) ; return matcher . toMatchResult ( ) ; } private static final ClassToInstanceMap < Object > DEFAULTS = ImmutableClassToInstanceMap . builder ( ) . put ( Object . class , <str> ) . put ( Number . class , <int> ) . put ( UnsignedInteger . class , UnsignedInteger . ZERO ) . put ( UnsignedLong . class , UnsignedLong . ZERO ) . put ( BigInteger . class , BigInteger . ZERO ) . put ( BigDecimal . class , BigDecimal . ZERO ) . put ( CharSequence . class , <str> ) . put ( String . class , <str> ) . put ( Pattern . class , Pattern . compile ( <str> ) ) . put ( MatchResult . class , newMatchResult ( ) ) . put ( TimeUnit . class , TimeUnit . SECONDS ) . put ( Charset . class , Charsets . UTF_8 ) . put ( Currency . class , Currency . getInstance ( Locale . US ) ) . put ( Locale . class , Locale . US ) . put ( CharMatcher . class , CharMatcher . NONE ) . put ( Joiner . class , Joiner . on ( <str> ) ) . put ( Splitter . class , Splitter . on ( <str> ) ) . put ( Optional . class , Optional . absent ( ) ) . put ( Predicate . class , Predicates . alwaysTrue ( ) ) . put ( Equivalence . class , Equivalence . equals ( ) ) . put ( Ticker . class , Ticker . systemTicker ( ) ) . put ( Stopwatch . class , Stopwatch . createUnstarted ( ) ) . put ( InputStream . class , new ByteArrayInputStream ( new byte [ <int> ] ) ) . put ( ByteArrayInputStream . class , new ByteArrayInputStream ( new byte [ <int> ] ) ) . put ( Readable . class , new StringReader ( <str> ) ) . put ( Reader . class , new StringReader ( <str> ) ) . put ( StringReader . class , new StringReader ( <str> ) ) . put ( Buffer . class , ByteBuffer . allocate ( <int> ) ) . put ( CharBuffer . class , CharBuffer . allocate ( <int> ) ) . put ( ByteBuffer . class , ByteBuffer . allocate ( <int> ) ) . put ( ShortBuffer . class , ShortBuffer . allocate ( <int> ) ) . put ( IntBuffer . class , IntBuffer . allocate ( <int> ) ) . put ( LongBuffer . class , LongBuffer . allocate ( <int> ) ) . put ( FloatBuffer . class , FloatBuffer . allocate ( <int> ) ) . put ( DoubleBuffer . class , DoubleBuffer . allocate ( <int> ) ) . put ( File . class , new File ( <str> ) ) . put ( ByteSource . class , ByteSource . empty ( ) ) . put ( CharSource . class , CharSource . empty ( ) ) . put ( ByteSink . class , NullByteSink . INSTANCE ) . put ( CharSink . class , NullByteSink . INSTANCE . asCharSink ( Charsets . UTF_8 ) ) . put ( Iterator . class , ImmutableSet . of ( ) . iterator ( ) ) . put ( PeekingIterator . class , Iterators . peekingIterator ( ImmutableSet . of ( ) . iterator ( ) ) ) . put ( ListIterator . class , ImmutableList . of ( ) . listIterator ( ) ) . put ( Iterable . class , ImmutableSet . of ( ) ) . put ( Collection . class , ImmutableList . of ( ) ) . put ( ImmutableCollection . class , ImmutableList . of ( ) ) . put ( List . class , ImmutableList . of ( ) ) . put ( ImmutableList . class , ImmutableList . of ( ) ) . put ( Set . class , ImmutableSet . of ( ) ) . put ( ImmutableSet . class , ImmutableSet . of ( ) ) . put ( SortedSet . class , ImmutableSortedSet . of ( ) ) . put ( ImmutableSortedSet . class , ImmutableSortedSet . of ( ) ) . put ( NavigableSet . class , Sets . unmodifiableNavigableSet ( Sets . newTreeSet ( ) ) ) . put ( Map . class , ImmutableMap . of ( ) ) . put ( ImmutableMap . class , ImmutableMap . of ( ) ) . put ( SortedMap . class , ImmutableSortedMap . of ( ) ) . put ( ImmutableSortedMap . class , ImmutableSortedMap . of ( ) ) . put ( NavigableMap . class , Maps . unmodifiableNavigableMap ( Maps . newTreeMap ( ) ) ) . put ( Multimap . class , ImmutableMultimap . of ( ) ) . put ( ImmutableMultimap . class , ImmutableMultimap . of ( ) ) . put ( ListMultimap . class , ImmutableListMultimap . of ( ) ) . put ( ImmutableListMultimap . class , ImmutableListMultimap . of ( ) ) . put ( SetMultimap . class , ImmutableSetMultimap . of ( ) ) . put ( ImmutableSetMultimap . class , ImmutableSetMultimap . of ( ) ) . put ( SortedSetMultimap . class , Multimaps . unmodifiableSortedSetMultimap ( TreeMultimap . create ( ) ) ) . put ( Multiset . class , ImmutableMultiset . of ( ) ) . put ( ImmutableMultiset . class , ImmutableMultiset . of ( ) ) . put ( SortedMultiset . class , ImmutableSortedMultiset . of ( ) ) . put ( ImmutableSortedMultiset . class , ImmutableSortedMultiset . of ( ) ) . put ( BiMap . class , ImmutableBiMap . of ( ) ) . put ( ImmutableBiMap . class , ImmutableBiMap . of ( ) ) . put ( Table . class , ImmutableTable . of ( ) ) . put ( ImmutableTable . class , ImmutableTable . of ( ) ) . put ( RowSortedTable . class , Tables . unmodifiableRowSortedTable ( TreeBasedTable . create ( ) ) ) . put ( ClassToInstanceMap . class , ImmutableClassToInstanceMap . builder ( ) . build ( ) ) . put ( ImmutableClassToInstanceMap . class , ImmutableClassToInstanceMap . builder ( ) . build ( ) ) . put ( Comparable . class , ByToString . INSTANCE ) . put ( Comparator . class , AlwaysEqual . INSTANCE ) . put ( Ordering . class , AlwaysEqual . INSTANCE ) . put ( Range . class , Range . all ( ) ) . put ( MapConstraint . class , MapConstraints . notNull ( ) ) . put ( MapDifference . class , Maps . difference ( ImmutableMap . of ( ) , ImmutableMap . of ( ) ) ) . put ( SortedMapDifference . class , Maps . difference ( ImmutableSortedMap . of ( ) , ImmutableSortedMap . of ( ) ) ) . put ( AnnotatedElement . class , Object . class ) . put ( GenericDeclaration . class , Object . class ) . put ( Type . class , Object . class ) . build ( ) ; private static final ConcurrentMap < Class < ? > , Class < ? > > implementations = Maps . newConcurrentMap ( ) ; private static < T > void setImplementation ( Class < T > type , Class < ? extends T > implementation ) { checkArgument ( type ! = implementation , <str> , type ) ; checkArgument ( ! DEFAULTS . containsKey ( type ) , <str> , type ) ; checkArgument ( implementations . put ( type , implementation ) = = null , <str> , type ) ; } static { setImplementation ( Appendable . class , StringBuilder . class ) ; setImplementation ( BlockingQueue . class , LinkedBlockingDeque . class ) ; setImplementation ( BlockingDeque . class , LinkedBlockingDeque . class ) ; setImplementation ( ConcurrentMap . class , ConcurrentHashMap . class ) ; setImplementation ( ConcurrentNavigableMap . class , ConcurrentSkipListMap . class ) ; setImplementation ( CountDownLatch . class , Dummies . DummyCountDownLatch . class ) ; setImplementation ( Deque . class , ArrayDeque . class ) ; setImplementation ( OutputStream . class , ByteArrayOutputStream . class ) ; setImplementation ( PrintStream . class , Dummies . InMemoryPrintStream . class ) ; setImplementation ( PrintWriter . class , Dummies . InMemoryPrintWriter . class ) ; setImplementation ( Queue . class , ArrayDeque . class ) ; setImplementation ( Random . class , Dummies . DeterministicRandom . class ) ; setImplementation ( ScheduledThreadPoolExecutor . class , Dummies . DummyScheduledThreadPoolExecutor . class ) ; setImplementation ( ThreadPoolExecutor . class , Dummies . DummyScheduledThreadPoolExecutor . class ) ; setImplementation ( Writer . class , StringWriter . class ) ; setImplementation ( Runnable . class , Dummies . DummyRunnable . class ) ; setImplementation ( ThreadFactory . class , Dummies . DummyThreadFactory . class ) ; setImplementation ( Executor . class , Dummies . DummyExecutor . class ) ; } @SuppressWarnings ( <str> ) @Nullable private static < T > Class < ? extends T > getImplementation ( Class < T > type ) { return ( Class < ? extends T > ) implementations . get ( type ) ; } private static final Logger logger = Logger . getLogger ( ArbitraryInstances . class . getName ( ) ) ; @Nullable public static < T > T get ( Class < T > type ) { T defaultValue = DEFAULTS . getInstance ( type ) ; if ( defaultValue ! = null ) { return defaultValue ; } Class < ? extends T > implementation = getImplementation ( type ) ; if ( implementation ! = null ) { return get ( implementation ) ; } if ( type . isEnum ( ) ) { T [ ] enumConstants = type . getEnumConstants ( ) ; return ( enumConstants . length = = <int> ) ? null : enumConstants [ <int> ] ; } if ( type . isArray ( ) ) { return createEmptyArray ( type ) ; } T jvmDefault = Defaults . defaultValue ( Primitives . unwrap ( type ) ) ; if ( jvmDefault ! = null ) { return jvmDefault ; } if ( Modifier . isAbstract ( type . getModifiers ( ) ) | | ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return arbitraryConstantInstanceOrNull ( type ) ; } final Constructor < T > constructor ; try { constructor = type . getConstructor ( ) ; } catch ( NoSuchMethodException e ) { return arbitraryConstantInstanceOrNull ( type ) ; } constructor . setAccessible ( true ) ; try { return constructor . newInstance ( ) ; } catch ( InstantiationException impossible ) { throw new AssertionError ( impossible ) ; } catch ( IllegalAccessException impossible ) { throw new AssertionError ( impossible ) ; } catch ( InvocationTargetException e ) { logger . log ( Level . WARNING , <str> , e . getCause ( ) ) ; return arbitraryConstantInstanceOrNull ( type ) ; } } @Nullable private static < T > T arbitraryConstantInstanceOrNull ( Class < T > type ) { Field [ ] fields = type . getDeclaredFields ( ) ; Arrays . sort ( fields , BY_FIELD_NAME ) ; for ( Field field : fields ) { if ( Modifier . isPublic ( field . getModifiers ( ) ) & & Modifier . isStatic ( field . getModifiers ( ) ) & & Modifier . isFinal ( field . getModifiers ( ) ) ) { if ( field . getGenericType ( ) = = field . getType ( ) & & type . isAssignableFrom ( field . getType ( ) ) ) { field . setAccessible ( true ) ; try { T constant = type . cast ( field . get ( null ) ) ; if ( constant ! = null ) { return constant ; } } catch ( IllegalAccessException impossible ) { throw new AssertionError ( impossible ) ; } } } } return null ; } private static < T > T createEmptyArray ( Class < T > arrayType ) { return arrayType . cast ( Array . newInstance ( arrayType . getComponentType ( ) , <int> ) ) ; } private static final class Dummies { public static final class InMemoryPrintStream extends PrintStream { public InMemoryPrintStream ( ) { super ( new ByteArrayOutputStream ( ) ) ; } } public static final class InMemoryPrintWriter extends PrintWriter { public InMemoryPrintWriter ( ) { super ( new StringWriter ( ) ) ; } } public static final class DeterministicRandom extends Random { public DeterministicRandom ( ) { super ( <int> ) ; } } public static final class DummyScheduledThreadPoolExecutor extends ScheduledThreadPoolExecutor { public DummyScheduledThreadPoolExecutor ( ) { super ( <int> ) ; } } public static final class DummyCountDownLatch extends CountDownLatch { public DummyCountDownLatch ( ) { super ( <int> ) ; } } public static final class DummyRunnable implements Runnable , Serializable { @Override public void run ( ) { } } public static final class DummyThreadFactory implements ThreadFactory , Serializable { @Override public Thread newThread ( Runnable r ) { return new Thread ( r ) ; } } public static final class DummyExecutor implements Executor , Serializable { @Override public void execute ( Runnable command ) { } } } private static final class NullByteSink extends ByteSink implements Serializable { private static final NullByteSink INSTANCE = new NullByteSink ( ) ; @Override public OutputStream openStream ( ) { return ByteStreams . nullOutputStream ( ) ; } } private static final class ByToString implements Comparable < Object > , Serializable { private static final ByToString INSTANCE = new ByToString ( ) ; @Override public int compareTo ( Object o ) { return toString ( ) . compareTo ( o . toString ( ) ) ; } @Override public String toString ( ) { return <str> ; } private Object readResolve ( ) { return INSTANCE ; } } private static final class AlwaysEqual extends Ordering < Object > implements Serializable { private static final AlwaysEqual INSTANCE = new AlwaysEqual ( ) ; @Override public int compare ( Object o1 , Object o2 ) { return <int> ; } @Override public String toString ( ) { return <str> ; } private Object readResolve ( ) { return INSTANCE ; } } private ArbitraryInstances ( ) { } } 
