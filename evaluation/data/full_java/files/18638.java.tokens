package com . badlogic . gdx . tests . bullet ; import com . badlogic . gdx . Input . Buttons ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . VertexAttributes . Usage ; import com . badlogic . gdx . graphics . g3d . Material ; import com . badlogic . gdx . graphics . g3d . Model ; import com . badlogic . gdx . graphics . g3d . attributes . ColorAttribute ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . math . Matrix4 ; import com . badlogic . gdx . math . Vector3 ; import com . badlogic . gdx . math . collision . Ray ; import com . badlogic . gdx . physics . bullet . collision . Collision ; import com . badlogic . gdx . physics . bullet . collision . btCapsuleShape ; import com . badlogic . gdx . physics . bullet . collision . ClosestRayResultCallback ; import com . badlogic . gdx . physics . bullet . dynamics . btConeTwistConstraint ; import com . badlogic . gdx . physics . bullet . dynamics . btConstraintSetting ; import com . badlogic . gdx . physics . bullet . dynamics . btDynamicsWorld ; import com . badlogic . gdx . physics . bullet . dynamics . btHingeConstraint ; import com . badlogic . gdx . physics . bullet . dynamics . btPoint2PointConstraint ; import com . badlogic . gdx . physics . bullet . dynamics . btRigidBody ; import com . badlogic . gdx . physics . bullet . dynamics . btTypedConstraint ; import com . badlogic . gdx . utils . Array ; public class RayPickRagdollTest extends BaseBulletTest { final Array < btTypedConstraint > constraints = new Array < btTypedConstraint > ( ) ; btPoint2PointConstraint pickConstraint = null ; btRigidBody pickedBody = null ; float pickDistance ; Vector3 tmpV = new Vector3 ( ) ; @Override public void create ( ) { super . create ( ) ; instructions = <str> ; camera . position . set ( <float> , <float> , <float> ) ; camera . lookAt ( <float> , <float> , <float> ) ; camera . update ( ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . addConstructor ( <str> , new BulletConstructor ( createCapsuleModel ( <float> , <float> ) , <float> , new btCapsuleShape ( <float> , <float> ) ) ) ; world . add ( <str> , <float> , <float> , <float> ) . setColor ( <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> + <float> * ( float ) Math . random ( ) , <float> ) ; addRagdoll ( <int> , <float> , <int> ) ; addRagdoll ( <float> , <float> , <int> ) ; addRagdoll ( - <float> , <int> f , <int> ) ; } @Override public void dispose ( ) { for ( int i = <int> ; i < constraints . size ; i + + ) { ( ( btDynamicsWorld ) world . collisionWorld ) . removeConstraint ( constraints . get ( i ) ) ; constraints . get ( i ) . dispose ( ) ; } constraints . clear ( ) ; super . dispose ( ) ; } @Override public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { boolean result = false ; if ( button = = Buttons . LEFT ) { Ray ray = camera . getPickRay ( screenX , screenY ) ; tmpV1 . set ( ray . direction ) . scl ( <int> f ) . add ( ray . origin ) ; ClosestRayResultCallback cb = new ClosestRayResultCallback ( ray . origin , tmpV1 ) ; world . collisionWorld . rayTest ( ray . origin , tmpV1 , cb ) ; if ( cb . hasHit ( ) ) { btRigidBody body = ( btRigidBody ) ( cb . getCollisionObject ( ) ) ; if ( body ! = null & & ! body . isStaticObject ( ) & & ! body . isKinematicObject ( ) ) { pickedBody = body ; body . setActivationState ( Collision . DISABLE_DEACTIVATION ) ; cb . getHitPointWorld ( tmpV ) ; tmpV . mul ( body . getCenterOfMassTransform ( ) . inv ( ) ) ; pickConstraint = new btPoint2PointConstraint ( body , tmpV ) ; btConstraintSetting setting = pickConstraint . getSetting ( ) ; setting . setImpulseClamp ( <int> f ) ; setting . setTau ( <float> ) ; pickConstraint . setSetting ( setting ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( pickConstraint ) ; pickDistance = tmpV1 . sub ( camera . position ) . len ( ) ; result = true ; } } cb . dispose ( ) ; } return result ? result : super . touchDown ( screenX , screenY , pointer , button ) ; } @Override public boolean touchUp ( int screenX , int screenY , int pointer , int button ) { boolean result = false ; if ( button = = Buttons . LEFT ) { if ( pickConstraint ! = null ) { ( ( btDynamicsWorld ) world . collisionWorld ) . removeConstraint ( pickConstraint ) ; pickConstraint . dispose ( ) ; pickConstraint = null ; result = true ; } if ( pickedBody ! = null ) { pickedBody . forceActivationState ( Collision . ACTIVE_TAG ) ; pickedBody . setDeactivationTime ( <float> ) ; pickedBody = null ; } } return result ? result : super . touchUp ( screenX , screenY , pointer , button ) ; } @Override public boolean touchDragged ( int screenX , int screenY , int pointer ) { boolean result = false ; if ( pickConstraint ! = null ) { Ray ray = camera . getPickRay ( screenX , screenY ) ; tmpV1 . set ( ray . direction ) . scl ( pickDistance ) . add ( camera . position ) ; pickConstraint . setPivotB ( tmpV1 ) ; result = true ; } return result ? result : super . touchDragged ( screenX , screenY , pointer ) ; } @Override public boolean tap ( float x , float y , int count , int button ) { shoot ( x , y ) ; return true ; } final static float PI = MathUtils . PI ; final static float PI2 = <float> * PI ; final static float PI4 = <float> * PI ; public void addRagdoll ( final float x , final float y , final float z ) { final Matrix4 tmpM = new Matrix4 ( ) ; btRigidBody pelvis = ( btRigidBody ) world . add ( <str> , x , y + <int> , z ) . body ; btRigidBody spine = ( btRigidBody ) world . add ( <str> , x , y + <float> , z ) . body ; btRigidBody head = ( btRigidBody ) world . add ( <str> , x , y + <float> , z ) . body ; btRigidBody leftupperleg = ( btRigidBody ) world . add ( <str> , x - <float> , y + <float> , z ) . body ; btRigidBody leftlowerleg = ( btRigidBody ) world . add ( <str> , x - <float> , y + <float> , z ) . body ; btRigidBody rightupperleg = ( btRigidBody ) world . add ( <str> , x + <float> , y + <float> , z ) . body ; btRigidBody rightlowerleg = ( btRigidBody ) world . add ( <str> , x + <float> , y + <float> , z ) . body ; btRigidBody leftupperarm = ( btRigidBody ) world . add ( <str> , tmpM . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( x - <float> , y + <float> , z ) ) . body ; btRigidBody leftlowerarm = ( btRigidBody ) world . add ( <str> , tmpM . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( x - <float> , y + <float> , z ) ) . body ; btRigidBody rightupperarm = ( btRigidBody ) world . add ( <str> , tmpM . setFromEulerAnglesRad ( - PI2 , <int> , <int> ) . trn ( x + <float> , y + <float> , z ) ) . body ; btRigidBody rightlowerarm = ( btRigidBody ) world . add ( <str> , tmpM . setFromEulerAnglesRad ( - PI2 , <int> , <int> ) . trn ( x + <float> , y + <float> , z ) ) . body ; final Matrix4 localA = new Matrix4 ( ) ; final Matrix4 localB = new Matrix4 ( ) ; btHingeConstraint hingeC = null ; btConeTwistConstraint coneC = null ; localA . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( hingeC = new btHingeConstraint ( pelvis , spine , localA , localB ) ) ; hingeC . setLimit ( - PI4 , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( hingeC , true ) ; localA . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( <int> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( coneC = new btConeTwistConstraint ( spine , head , localA , localB ) ) ; coneC . setLimit ( PI4 , PI4 , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( coneC , true ) ; localA . setFromEulerAnglesRad ( - PI4 * <float> , <int> , <int> ) . trn ( - <float> , - <float> , <int> ) ; localB . setFromEulerAnglesRad ( - PI4 * <float> , <int> , <int> ) . trn ( <int> , <float> , <int> ) ; constraints . add ( coneC = new btConeTwistConstraint ( pelvis , leftupperleg , localA , localB ) ) ; coneC . setLimit ( PI4 , PI4 , <int> ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( coneC , true ) ; localA . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , - <float> , <int> ) ; localB . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , <float> , <int> ) ; constraints . add ( hingeC = new btHingeConstraint ( leftupperleg , leftlowerleg , localA , localB ) ) ; hingeC . setLimit ( <int> , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( hingeC , true ) ; localA . setFromEulerAnglesRad ( - PI4 * <float> , <int> , <int> ) . trn ( <float> , - <float> , <int> ) ; localB . setFromEulerAnglesRad ( - PI4 * <float> , <int> , <int> ) . trn ( <int> , <float> , <int> ) ; constraints . add ( coneC = new btConeTwistConstraint ( pelvis , rightupperleg , localA , localB ) ) ; coneC . setLimit ( PI4 , PI4 , <int> ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( coneC , true ) ; localA . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , - <float> , <int> ) ; localB . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , <float> , <int> ) ; constraints . add ( hingeC = new btHingeConstraint ( rightupperleg , rightlowerleg , localA , localB ) ) ; hingeC . setLimit ( <int> , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( hingeC , true ) ; localA . setFromEulerAnglesRad ( PI , <int> , <int> ) . trn ( - <float> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( coneC = new btConeTwistConstraint ( pelvis , leftupperarm , localA , localB ) ) ; coneC . setLimit ( PI2 , PI2 , <int> ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( coneC , true ) ; localA . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( hingeC = new btHingeConstraint ( leftupperarm , leftlowerarm , localA , localB ) ) ; hingeC . setLimit ( <int> , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( hingeC , true ) ; localA . setFromEulerAnglesRad ( PI , <int> , <int> ) . trn ( <float> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( PI2 , <int> , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( coneC = new btConeTwistConstraint ( pelvis , rightupperarm , localA , localB ) ) ; coneC . setLimit ( PI2 , PI2 , <int> ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( coneC , true ) ; localA . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , <float> , <int> ) ; localB . setFromEulerAnglesRad ( <int> , PI2 , <int> ) . trn ( <int> , - <float> , <int> ) ; constraints . add ( hingeC = new btHingeConstraint ( rightupperarm , rightlowerarm , localA , localB ) ) ; hingeC . setLimit ( <int> , PI2 ) ; ( ( btDynamicsWorld ) world . collisionWorld ) . addConstraint ( hingeC , true ) ; } protected Model createCapsuleModel ( float radius , float height ) { final Model result = modelBuilder . createCapsule ( radius , height + radius * <float> , <int> , new Material ( ColorAttribute . createDiffuse ( Color . WHITE ) , ColorAttribute . createSpecular ( Color . WHITE ) ) , Usage . Position | Usage . Normal ) ; disposables . add ( result ) ; return result ; } } 
