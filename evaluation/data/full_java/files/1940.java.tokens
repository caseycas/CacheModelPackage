package clojure . lang ; import java . util . concurrent . ConcurrentMap ; import java . util . * ; public class TransactionalHashMap < K , V > extends AbstractMap < K , V > implements ConcurrentMap < K , V > { final Ref [ ] bins ; IPersistentMap mapAt ( int bin ) { return ( IPersistentMap ) bins [ bin ] . deref ( ) ; } final int binFor ( Object k ) { int h = k . hashCode ( ) ; h ^ = ( h > > > <int> ) ^ ( h > > > <int> ) ; h ^ = ( h > > > <int> ) ^ ( h > > > <int> ) ; return h % bins . length ; } Entry entryAt ( Object k ) { return mapAt ( binFor ( k ) ) . entryAt ( k ) ; } public TransactionalHashMap ( ) { this ( <int> ) ; } public TransactionalHashMap ( int nBins ) { bins = new Ref [ nBins ] ; for ( int i = <int> ; i < nBins ; i + + ) bins [ i ] = new Ref ( PersistentHashMap . EMPTY ) ; } public TransactionalHashMap ( Map < ? extends K , ? extends V > m ) { this ( m . size ( ) ) ; putAll ( m ) ; } public int size ( ) { int n = <int> ; for ( int i = <int> ; i < bins . length ; i + + ) { n + = mapAt ( i ) . count ( ) ; } return n ; } public boolean isEmpty ( ) { return size ( ) = = <int> ; } public boolean containsKey ( Object k ) { return entryAt ( k ) ! = null ; } public V get ( Object k ) { Entry e = entryAt ( k ) ; if ( e ! = null ) return ( V ) e . getValue ( ) ; return null ; } public V put ( K k , V v ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Object ret = map . valAt ( k ) ; r . set ( map . assoc ( k , v ) ) ; return ( V ) ret ; } public V remove ( Object k ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Object ret = map . valAt ( k ) ; r . set ( map . without ( k ) ) ; return ( V ) ret ; } public void putAll ( Map < ? extends K , ? extends V > map ) { for ( Iterator i = map . entrySet ( ) . iterator ( ) ; i . hasNext ( ) ; ) { Entry < K , V > e = ( Entry ) i . next ( ) ; put ( e . getKey ( ) , e . getValue ( ) ) ; } } public void clear ( ) { for ( int i = <int> ; i < bins . length ; i + + ) { Ref r = bins [ i ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; if ( map . count ( ) > <int> ) { r . set ( PersistentHashMap . EMPTY ) ; } } } public Set < Entry < K , V > > entrySet ( ) { final ArrayList < Map . Entry < K , V > > entries = new ArrayList ( bins . length ) ; for ( int i = <int> ; i < bins . length ; i + + ) { IPersistentMap map = mapAt ( i ) ; if ( map . count ( ) > <int> ) entries . addAll ( ( Collection ) RT . seq ( map ) ) ; } return new AbstractSet < Entry < K , V > > ( ) { public Iterator iterator ( ) { return Collections . unmodifiableList ( entries ) . iterator ( ) ; } public int size ( ) { return entries . size ( ) ; } } ; } public V putIfAbsent ( K k , V v ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Entry e = map . entryAt ( k ) ; if ( e = = null ) { r . set ( map . assoc ( k , v ) ) ; return null ; } else return ( V ) e . getValue ( ) ; } public boolean remove ( Object k , Object v ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Entry e = map . entryAt ( k ) ; if ( e ! = null & & e . getValue ( ) . equals ( v ) ) { r . set ( map . without ( k ) ) ; return true ; } return false ; } public boolean replace ( K k , V oldv , V newv ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Entry e = map . entryAt ( k ) ; if ( e ! = null & & e . getValue ( ) . equals ( oldv ) ) { r . set ( map . assoc ( k , newv ) ) ; return true ; } return false ; } public V replace ( K k , V v ) { Ref r = bins [ binFor ( k ) ] ; IPersistentMap map = ( IPersistentMap ) r . deref ( ) ; Entry e = map . entryAt ( k ) ; if ( e ! = null ) { r . set ( map . assoc ( k , v ) ) ; return ( V ) e . getValue ( ) ; } return null ; } } 
