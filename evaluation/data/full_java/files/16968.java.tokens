package java . nio ; import com . google . gwt . corp . compatibility . Numbers ; final class ReadWriteHeapByteBuffer extends HeapByteBuffer { static ReadWriteHeapByteBuffer copy ( HeapByteBuffer other , int markOfOther ) { ReadWriteHeapByteBuffer buf = new ReadWriteHeapByteBuffer ( other . backingArray , other . capacity ( ) , other . offset ) ; buf . limit = other . limit ( ) ; buf . position = other . position ( ) ; buf . mark = markOfOther ; buf . order ( other . order ( ) ) ; return buf ; } ReadWriteHeapByteBuffer ( byte [ ] backingArray ) { super ( backingArray ) ; } ReadWriteHeapByteBuffer ( int capacity ) { super ( capacity ) ; } ReadWriteHeapByteBuffer ( byte [ ] backingArray , int capacity , int arrayOffset ) { super ( backingArray , capacity , arrayOffset ) ; } public ByteBuffer asReadOnlyBuffer ( ) { return ReadOnlyHeapByteBuffer . copy ( this , mark ) ; } public ByteBuffer compact ( ) { System . arraycopy ( backingArray , position + offset , backingArray , offset , remaining ( ) ) ; position = limit - position ; limit = capacity ; mark = UNSET_MARK ; return this ; } public ByteBuffer duplicate ( ) { return copy ( this , mark ) ; } public boolean isReadOnly ( ) { return false ; } protected byte [ ] protectedArray ( ) { return backingArray ; } protected int protectedArrayOffset ( ) { return offset ; } protected boolean protectedHasArray ( ) { return true ; } public ByteBuffer put ( byte b ) { if ( position = = limit ) { throw new BufferOverflowException ( ) ; } backingArray [ offset + position + + ] = b ; return this ; } public ByteBuffer put ( int index , byte b ) { if ( index < <int> | | index > = limit ) { throw new IndexOutOfBoundsException ( ) ; } backingArray [ offset + index ] = b ; return this ; } public ByteBuffer put ( byte [ ] src , int off , int len ) { if ( off < <int> | | len < <int> | | ( long ) off + ( long ) len > src . length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferOverflowException ( ) ; } if ( isReadOnly ( ) ) { throw new ReadOnlyBufferException ( ) ; } System . arraycopy ( src , off , backingArray , offset + position , len ) ; position + = len ; return this ; } public ByteBuffer putDouble ( double value ) { return putLong ( Numbers . doubleToRawLongBits ( value ) ) ; } public ByteBuffer putDouble ( int index , double value ) { return putLong ( index , Numbers . doubleToRawLongBits ( value ) ) ; } public ByteBuffer putFloat ( float value ) { return putInt ( Numbers . floatToIntBits ( value ) ) ; } public ByteBuffer putFloat ( int index , float value ) { return putInt ( index , Numbers . floatToIntBits ( value ) ) ; } public ByteBuffer putInt ( int value ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } store ( position , value ) ; position = newPosition ; return this ; } public ByteBuffer putInt ( int index , int value ) { if ( index < <int> | | ( long ) index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } store ( index , value ) ; return this ; } public ByteBuffer putLong ( int index , long value ) { if ( index < <int> | | ( long ) index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } store ( index , value ) ; return this ; } public ByteBuffer putLong ( long value ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } store ( position , value ) ; position = newPosition ; return this ; } public ByteBuffer putShort ( int index , short value ) { if ( index < <int> | | ( long ) index + <int> > limit ) { throw new IndexOutOfBoundsException ( ) ; } store ( index , value ) ; return this ; } public ByteBuffer putShort ( short value ) { int newPosition = position + <int> ; if ( newPosition > limit ) { throw new BufferOverflowException ( ) ; } store ( position , value ) ; position = newPosition ; return this ; } public ByteBuffer slice ( ) { ReadWriteHeapByteBuffer slice = new ReadWriteHeapByteBuffer ( backingArray , remaining ( ) , offset + position ) ; slice . order = order ; return slice ; } } 
