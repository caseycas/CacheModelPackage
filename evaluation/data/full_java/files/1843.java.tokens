package clojure . lang ; public class Cycle extends ASeq implements IReduce , IPending { private final ISeq all ; private final ISeq prev ; private volatile ISeq _current ; private volatile ISeq _next ; private Cycle ( ISeq all , ISeq prev , ISeq current ) { this . all = all ; this . prev = prev ; this . _current = current ; } private Cycle ( IPersistentMap meta , ISeq all , ISeq prev , ISeq current , ISeq next ) { super ( meta ) ; this . all = all ; this . prev = prev ; this . _current = current ; this . _next = next ; } public static ISeq create ( ISeq vals ) { if ( vals = = null ) return PersistentList . EMPTY ; return new Cycle ( vals , null , vals ) ; } private ISeq current ( ) { if ( _current = = null ) { ISeq current = prev . next ( ) ; _current = ( current = = null ) ? all : current ; } return _current ; } public boolean isRealized ( ) { return _current ! = null ; } public Object first ( ) { return current ( ) . first ( ) ; } public ISeq next ( ) { if ( _next = = null ) _next = new Cycle ( all , current ( ) , null ) ; return _next ; } public Cycle withMeta ( IPersistentMap meta ) { return new Cycle ( meta , all , prev , _current , _next ) ; } public Object reduce ( IFn f ) { ISeq s = current ( ) ; Object ret = s . first ( ) ; while ( true ) { s = s . next ( ) ; if ( s = = null ) s = all ; ret = f . invoke ( ret , s . first ( ) ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; } } public Object reduce ( IFn f , Object start ) { Object ret = start ; ISeq s = current ( ) ; while ( true ) { ret = f . invoke ( ret , s . first ( ) ) ; if ( RT . isReduced ( ret ) ) return ( ( IDeref ) ret ) . deref ( ) ; s = s . next ( ) ; if ( s = = null ) s = all ; } } } 
