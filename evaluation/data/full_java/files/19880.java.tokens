package io . netty . example . securechat ; import io . netty . channel . Channel ; import io . netty . channel . ChannelHandlerContext ; import io . netty . channel . SimpleChannelInboundHandler ; import io . netty . channel . group . ChannelGroup ; import io . netty . channel . group . DefaultChannelGroup ; import io . netty . handler . ssl . SslHandler ; import io . netty . util . concurrent . Future ; import io . netty . util . concurrent . GenericFutureListener ; import io . netty . util . concurrent . GlobalEventExecutor ; import java . net . InetAddress ; public class SecureChatServerHandler extends SimpleChannelInboundHandler < String > { static final ChannelGroup channels = new DefaultChannelGroup ( GlobalEventExecutor . INSTANCE ) ; @Override public void channelActive ( final ChannelHandlerContext ctx ) { ctx . pipeline ( ) . get ( SslHandler . class ) . handshakeFuture ( ) . addListener ( new GenericFutureListener < Future < Channel > > ( ) { @Override public void operationComplete ( Future < Channel > future ) throws Exception { ctx . writeAndFlush ( <str> + InetAddress . getLocalHost ( ) . getHostName ( ) + <str> ) ; ctx . writeAndFlush ( <str> + ctx . pipeline ( ) . get ( SslHandler . class ) . engine ( ) . getSession ( ) . getCipherSuite ( ) + <str> ) ; channels . add ( ctx . channel ( ) ) ; } } ) ; } @Override public void channelRead0 ( ChannelHandlerContext ctx , String msg ) throws Exception { for ( Channel c : channels ) { if ( c ! = ctx . channel ( ) ) { c . writeAndFlush ( <str> + ctx . channel ( ) . remoteAddress ( ) + <str> + msg + <str> ) ; } else { c . writeAndFlush ( <str> + msg + <str> ) ; } } if ( <str> . equals ( msg . toLowerCase ( ) ) ) { ctx . close ( ) ; } } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) { cause . printStackTrace ( ) ; ctx . close ( ) ; } } 
