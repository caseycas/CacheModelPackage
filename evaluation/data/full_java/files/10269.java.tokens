package com . google . common . cache ; import com . google . common . base . Function ; import com . google . common . base . MoreObjects ; import com . google . common . base . Objects ; import com . google . common . base . Optional ; import com . google . common . base . Preconditions ; import com . google . common . cache . LocalCache . Strength ; import com . google . common . collect . Iterables ; import com . google . common . collect . Lists ; import com . google . common . collect . Sets ; import java . util . List ; import java . util . Set ; import java . util . concurrent . TimeUnit ; import javax . annotation . Nullable ; class CacheBuilderFactory { private Set < Integer > concurrencyLevels = Sets . newHashSet ( ( Integer ) null ) ; private Set < Integer > initialCapacities = Sets . newHashSet ( ( Integer ) null ) ; private Set < Integer > maximumSizes = Sets . newHashSet ( ( Integer ) null ) ; private Set < DurationSpec > expireAfterWrites = Sets . newHashSet ( ( DurationSpec ) null ) ; private Set < DurationSpec > expireAfterAccesses = Sets . newHashSet ( ( DurationSpec ) null ) ; private Set < DurationSpec > refreshes = Sets . newHashSet ( ( DurationSpec ) null ) ; private Set < Strength > keyStrengths = Sets . newHashSet ( ( Strength ) null ) ; private Set < Strength > valueStrengths = Sets . newHashSet ( ( Strength ) null ) ; CacheBuilderFactory withConcurrencyLevels ( Set < Integer > concurrencyLevels ) { this . concurrencyLevels = Sets . newLinkedHashSet ( concurrencyLevels ) ; return this ; } CacheBuilderFactory withInitialCapacities ( Set < Integer > initialCapacities ) { this . initialCapacities = Sets . newLinkedHashSet ( initialCapacities ) ; return this ; } CacheBuilderFactory withMaximumSizes ( Set < Integer > maximumSizes ) { this . maximumSizes = Sets . newLinkedHashSet ( maximumSizes ) ; return this ; } CacheBuilderFactory withExpireAfterWrites ( Set < DurationSpec > durations ) { this . expireAfterWrites = Sets . newLinkedHashSet ( durations ) ; return this ; } CacheBuilderFactory withExpireAfterAccesses ( Set < DurationSpec > durations ) { this . expireAfterAccesses = Sets . newLinkedHashSet ( durations ) ; return this ; } CacheBuilderFactory withRefreshes ( Set < DurationSpec > durations ) { this . refreshes = Sets . newLinkedHashSet ( durations ) ; return this ; } CacheBuilderFactory withKeyStrengths ( Set < Strength > keyStrengths ) { this . keyStrengths = Sets . newLinkedHashSet ( keyStrengths ) ; Preconditions . checkArgument ( ! this . keyStrengths . contains ( Strength . SOFT ) ) ; return this ; } CacheBuilderFactory withValueStrengths ( Set < Strength > valueStrengths ) { this . valueStrengths = Sets . newLinkedHashSet ( valueStrengths ) ; return this ; } Iterable < CacheBuilder < Object , Object > > buildAllPermutations ( ) { @SuppressWarnings ( <str> ) Iterable < List < Object > > combinations = buildCartesianProduct ( concurrencyLevels , initialCapacities , maximumSizes , expireAfterWrites , expireAfterAccesses , refreshes , keyStrengths , valueStrengths ) ; return Iterables . transform ( combinations , new Function < List < Object > , CacheBuilder < Object , Object > > ( ) { @Override public CacheBuilder < Object , Object > apply ( List < Object > combination ) { return createCacheBuilder ( ( Integer ) combination . get ( <int> ) , ( Integer ) combination . get ( <int> ) , ( Integer ) combination . get ( <int> ) , ( DurationSpec ) combination . get ( <int> ) , ( DurationSpec ) combination . get ( <int> ) , ( DurationSpec ) combination . get ( <int> ) , ( Strength ) combination . get ( <int> ) , ( Strength ) combination . get ( <int> ) ) ; } } ) ; } private static final Function < Object , Optional < ? > > NULLABLE_TO_OPTIONAL = new Function < Object , Optional < ? > > ( ) { @Override public Optional < ? > apply ( @Nullable Object obj ) { return Optional . fromNullable ( obj ) ; } } ; private static final Function < Optional < ? > , Object > OPTIONAL_TO_NULLABLE = new Function < Optional < ? > , Object > ( ) { @Override public Object apply ( Optional < ? > optional ) { return optional . orNull ( ) ; } } ; private Iterable < List < Object > > buildCartesianProduct ( Set < ? > . . . sets ) { List < Set < Optional < ? > > > optionalSets = Lists . newArrayListWithExpectedSize ( sets . length ) ; for ( Set < ? > set : sets ) { Set < Optional < ? > > optionalSet = Sets . newLinkedHashSet ( Iterables . transform ( set , NULLABLE_TO_OPTIONAL ) ) ; optionalSets . add ( optionalSet ) ; } Set < List < Optional < ? > > > cartesianProduct = Sets . cartesianProduct ( optionalSets ) ; return Iterables . transform ( cartesianProduct , new Function < List < Optional < ? > > , List < Object > > ( ) { @Override public List < Object > apply ( List < Optional < ? > > objs ) { return Lists . transform ( objs , OPTIONAL_TO_NULLABLE ) ; } } ) ; } private CacheBuilder < Object , Object > createCacheBuilder ( Integer concurrencyLevel , Integer initialCapacity , Integer maximumSize , DurationSpec expireAfterWrite , DurationSpec expireAfterAccess , DurationSpec refresh , Strength keyStrength , Strength valueStrength ) { CacheBuilder < Object , Object > builder = CacheBuilder . newBuilder ( ) ; if ( concurrencyLevel ! = null ) { builder . concurrencyLevel ( concurrencyLevel ) ; } if ( initialCapacity ! = null ) { builder . initialCapacity ( initialCapacity ) ; } if ( maximumSize ! = null ) { builder . maximumSize ( maximumSize ) ; } if ( expireAfterWrite ! = null ) { builder . expireAfterWrite ( expireAfterWrite . duration , expireAfterWrite . unit ) ; } if ( expireAfterAccess ! = null ) { builder . expireAfterAccess ( expireAfterAccess . duration , expireAfterAccess . unit ) ; } if ( refresh ! = null ) { builder . refreshAfterWrite ( refresh . duration , refresh . unit ) ; } if ( keyStrength ! = null ) { builder . setKeyStrength ( keyStrength ) ; } if ( valueStrength ! = null ) { builder . setValueStrength ( valueStrength ) ; } return builder ; } static class DurationSpec { private final long duration ; private final TimeUnit unit ; private DurationSpec ( long duration , TimeUnit unit ) { this . duration = duration ; this . unit = unit ; } public static DurationSpec of ( long duration , TimeUnit unit ) { return new DurationSpec ( duration , unit ) ; } @Override public int hashCode ( ) { return Objects . hashCode ( duration , unit ) ; } @Override public boolean equals ( Object o ) { if ( o instanceof DurationSpec ) { DurationSpec that = ( DurationSpec ) o ; return unit . toNanos ( duration ) = = that . unit . toNanos ( that . duration ) ; } return false ; } @Override public String toString ( ) { return MoreObjects . toStringHelper ( this ) . add ( <str> , duration ) . add ( <str> , unit ) . toString ( ) ; } } } 
