package com . badlogic . gdx . tests ; import com . badlogic . gdx . Gdx ; import com . badlogic . gdx . InputAdapter ; import com . badlogic . gdx . graphics . Color ; import com . badlogic . gdx . graphics . GL20 ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer ; import com . badlogic . gdx . graphics . glutils . ShapeRenderer . ShapeType ; import com . badlogic . gdx . math . DelaunayTriangulator ; import com . badlogic . gdx . math . MathUtils ; import com . badlogic . gdx . tests . utils . GdxTest ; import com . badlogic . gdx . utils . FloatArray ; import com . badlogic . gdx . utils . ShortArray ; public class DelaunayTriangulatorTest extends GdxTest { private ShapeRenderer renderer ; FloatArray points = new FloatArray ( ) ; ShortArray triangles ; DelaunayTriangulator trianglulator = new DelaunayTriangulator ( ) ; long seed = MathUtils . random . nextLong ( ) ; public void create ( ) { renderer = new ShapeRenderer ( ) ; triangulate ( ) ; System . out . println ( seed ) ; Gdx . input . setInputProcessor ( new InputAdapter ( ) { public boolean touchDown ( int screenX , int screenY , int pointer , int button ) { seed = MathUtils . random . nextLong ( ) ; System . out . println ( seed ) ; triangulate ( ) ; return true ; } public boolean mouseMoved ( int screenX , int screenY ) { triangulate ( ) ; return false ; } } ) ; } void triangulate ( ) { MathUtils . random . setSeed ( seed ) ; int pointCount = <int> ; points . clear ( ) ; for ( int i = <int> ; i < pointCount ; i + + ) { float value ; do { value = MathUtils . random ( <int> , <int> ) ; } while ( points . contains ( value ) ) ; points . add ( value ) ; do { value = MathUtils . random ( <int> , <int> ) ; } while ( points . contains ( value ) ) ; points . add ( value ) ; } points . add ( Gdx . input . getX ( ) ) ; points . add ( Gdx . graphics . getHeight ( ) - Gdx . input . getY ( ) ) ; triangles = trianglulator . computeTriangles ( points , false ) ; } public void render ( ) { Gdx . gl . glClear ( GL20 . GL_COLOR_BUFFER_BIT ) ; renderer . setColor ( Color . RED ) ; renderer . begin ( ShapeType . Filled ) ; for ( int i = <int> ; i < points . size ; i + = <int> ) renderer . circle ( points . get ( i ) , points . get ( i + <int> ) , <int> , <int> ) ; renderer . end ( ) ; renderer . setColor ( Color . WHITE ) ; renderer . begin ( ShapeType . Line ) ; for ( int i = <int> ; i < triangles . size ; i + = <int> ) { int p1 = triangles . get ( i ) * <int> ; int p2 = triangles . get ( i + <int> ) * <int> ; int p3 = triangles . get ( i + <int> ) * <int> ; renderer . triangle ( points . get ( p1 ) , points . get ( p1 + <int> ) , points . get ( p2 ) , points . get ( p2 + <int> ) , points . get ( p3 ) , points . get ( p3 + <int> ) ) ; } renderer . end ( ) ; } public void resize ( int width , int height ) { renderer . getProjectionMatrix ( ) . setToOrtho2D ( <int> , <int> , width , height ) ; renderer . updateMatrices ( ) ; } } 
