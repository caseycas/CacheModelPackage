package java . nio ; abstract class CharArrayBuffer extends CharBuffer { protected final char [ ] backingArray ; protected final int offset ; CharArrayBuffer ( char [ ] array ) { this ( array . length , array , <int> ) ; } CharArrayBuffer ( int capacity ) { this ( capacity , new char [ capacity ] , <int> ) ; } CharArrayBuffer ( int capacity , char [ ] backingArray , int offset ) { super ( capacity ) ; this . backingArray = backingArray ; this . offset = offset ; } public final char get ( ) { if ( position = = limit ) { throw new BufferUnderflowException ( ) ; } return backingArray [ offset + position + + ] ; } public final char get ( int index ) { if ( index < <int> | | index > = limit ) { throw new IndexOutOfBoundsException ( ) ; } return backingArray [ offset + index ] ; } public final CharBuffer get ( char [ ] dest , int off , int len ) { int length = dest . length ; if ( ( off < <int> ) | | ( len < <int> ) | | ( long ) off + ( long ) len > length ) { throw new IndexOutOfBoundsException ( ) ; } if ( len > remaining ( ) ) { throw new BufferUnderflowException ( ) ; } System . arraycopy ( backingArray , offset + position , dest , off , len ) ; position + = len ; return this ; } public final boolean isDirect ( ) { return false ; } public final ByteOrder order ( ) { return ByteOrder . nativeOrder ( ) ; } public final CharSequence subSequence ( int start , int end ) { if ( start < <int> | | end < start | | end > remaining ( ) ) { throw new IndexOutOfBoundsException ( ) ; } CharBuffer result = duplicate ( ) ; result . limit ( position + end ) ; result . position ( position + start ) ; return result ; } public final String toString ( ) { return String . copyValueOf ( backingArray , offset + position , remaining ( ) ) ; } } 
