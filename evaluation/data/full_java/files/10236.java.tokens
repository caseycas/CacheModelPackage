package com . google . common . util . concurrent ; import static com . google . common . collect . Iterables . cycle ; import static com . google . common . collect . Iterables . limit ; import com . google . caliper . BeforeExperiment ; import com . google . caliper . Benchmark ; import com . google . caliper . Param ; import com . google . caliper . api . Footprint ; import com . google . caliper . api . VmOptions ; import com . google . common . base . Supplier ; import com . google . common . collect . ImmutableList ; import com . google . common . primitives . Ints ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; import java . util . Random ; import java . util . concurrent . locks . Lock ; import java . util . concurrent . locks . ReentrantLock ; @VmOptions ( { <str> , <str> , <str> } ) public class StripedBenchmark { private static final Supplier < Lock > LOCK_SUPPLIER = new Supplier < Lock > ( ) { @Override public Lock get ( ) { return new ReentrantLock ( ) ; } } ; @Param ( { <str> , <str> , <str> , <str> , <str> } ) int numStripes ; @Param Impl impl ; enum Impl { EAGER { @Override Striped < Lock > get ( int stripes ) { return Striped . lock ( stripes ) ; } } , LAZY_SMALL { @Override Striped < Lock > get ( int stripes ) { return new Striped . SmallLazyStriped < Lock > ( stripes , LOCK_SUPPLIER ) ; } } , LAZY_LARGE { @Override Striped < Lock > get ( int stripes ) { return new Striped . LargeLazyStriped < Lock > ( stripes , LOCK_SUPPLIER ) ; } } ; abstract Striped < Lock > get ( int stripes ) ; } private Striped < Lock > striped ; private int [ ] stripes ; private List < Integer > bulkGetSet ; @BeforeExperiment void setUp ( ) { this . striped = impl . get ( numStripes ) ; stripes = new int [ numStripes ] ; for ( int i = <int> ; i < numStripes ; i + + ) { stripes [ i ] = i ; } List < Integer > asList = Ints . asList ( stripes ) ; Collections . shuffle ( asList , new Random ( <hex> ) ) ; bulkGetSet = ImmutableList . copyOf ( limit ( cycle ( asList ) , <int> ) ) ; } @Footprint Object sizeOfStriped ( ) { return impl . get ( numStripes ) ; } final List < Lock > locks = new ArrayList < Lock > ( numStripes ) ; @Footprint Object sizeOfPopulatedStriped ( ) { locks . clear ( ) ; Striped < Lock > striped = impl . get ( numStripes ) ; for ( int i : stripes ) { locks . add ( striped . getAt ( i ) ) ; } return striped ; } @Benchmark long timeConstruct ( long reps ) { long rvalue = <int> ; int numStripesLocal = numStripes ; Impl implLocal = impl ; for ( long i = <int> ; i < reps ; i + + ) { rvalue + = implLocal . get ( numStripesLocal ) . hashCode ( ) ; } return rvalue ; } @Benchmark long timeGetAt ( long reps ) { long rvalue = <int> ; int [ ] stripesLocal = stripes ; int mask = numStripes - <int> ; Striped < Lock > stripedLocal = striped ; for ( long i = <int> ; i < reps ; i + + ) { rvalue + = stripedLocal . getAt ( stripesLocal [ ( int ) ( i & mask ) ] ) . hashCode ( ) ; } return rvalue ; } @Benchmark long timeBulkGet ( long reps ) { long rvalue = <int> ; List < Integer > bulkGetSetLocal = bulkGetSet ; Striped < Lock > stripedLocal = striped ; for ( long i = <int> ; i < reps ; i + + ) { rvalue + = stripedLocal . bulkGet ( bulkGetSetLocal ) . hashCode ( ) ; } return rvalue ; } } 
