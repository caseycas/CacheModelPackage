package org . apache . cassandra . streaming ; import java . net . InetAddress ; import java . util . Map ; import java . util . Set ; import java . util . UUID ; import javax . management . ListenerNotFoundException ; import javax . management . MBeanNotificationInfo ; import javax . management . NotificationFilter ; import javax . management . NotificationListener ; import javax . management . openmbean . CompositeData ; import com . google . common . base . Function ; import com . google . common . collect . Iterables ; import com . google . common . collect . Sets ; import com . google . common . util . concurrent . MoreExecutors ; import com . google . common . util . concurrent . RateLimiter ; import org . cliffc . high_scale_lib . NonBlockingHashMap ; import org . apache . cassandra . config . DatabaseDescriptor ; import org . apache . cassandra . streaming . management . StreamEventJMXNotifier ; import org . apache . cassandra . streaming . management . StreamStateCompositeData ; public class StreamManager implements StreamManagerMBean { public static final StreamManager instance = new StreamManager ( ) ; public static StreamRateLimiter getRateLimiter ( InetAddress peer ) { return new StreamRateLimiter ( peer ) ; } public static class StreamRateLimiter { private static final double BYTES_PER_MEGABIT = ( <int> * <int> ) / <int> ; private static final RateLimiter limiter = RateLimiter . create ( Double . MAX_VALUE ) ; private static final RateLimiter interDCLimiter = RateLimiter . create ( Double . MAX_VALUE ) ; private final boolean isLocalDC ; public StreamRateLimiter ( InetAddress peer ) { double throughput = DatabaseDescriptor . getStreamThroughputOutboundMegabitsPerSec ( ) * BYTES_PER_MEGABIT ; mayUpdateThroughput ( throughput , limiter ) ; double interDCThroughput = DatabaseDescriptor . getInterDCStreamThroughputOutboundMegabitsPerSec ( ) * BYTES_PER_MEGABIT ; mayUpdateThroughput ( interDCThroughput , interDCLimiter ) ; if ( DatabaseDescriptor . getLocalDataCenter ( ) ! = null & & DatabaseDescriptor . getEndpointSnitch ( ) ! = null ) isLocalDC = DatabaseDescriptor . getLocalDataCenter ( ) . equals ( DatabaseDescriptor . getEndpointSnitch ( ) . getDatacenter ( peer ) ) ; else isLocalDC = true ; } private void mayUpdateThroughput ( double limit , RateLimiter rateLimiter ) { if ( limit = = <int> ) limit = Double . MAX_VALUE ; if ( rateLimiter . getRate ( ) ! = limit ) rateLimiter . setRate ( limit ) ; } public void acquire ( int toTransfer ) { limiter . acquire ( toTransfer ) ; if ( ! isLocalDC ) interDCLimiter . acquire ( toTransfer ) ; } } private final StreamEventJMXNotifier notifier = new StreamEventJMXNotifier ( ) ; private final Map < UUID , StreamResultFuture > initiatedStreams = new NonBlockingHashMap < > ( ) ; private final Map < UUID , StreamResultFuture > receivingStreams = new NonBlockingHashMap < > ( ) ; public Set < CompositeData > getCurrentStreams ( ) { return Sets . newHashSet ( Iterables . transform ( Iterables . concat ( initiatedStreams . values ( ) , receivingStreams . values ( ) ) , new Function < StreamResultFuture , CompositeData > ( ) { public CompositeData apply ( StreamResultFuture input ) { return StreamStateCompositeData . toCompositeData ( input . getCurrentState ( ) ) ; } } ) ) ; } public void register ( final StreamResultFuture result ) { result . addEventListener ( notifier ) ; result . addListener ( new Runnable ( ) { public void run ( ) { initiatedStreams . remove ( result . planId ) ; } } , MoreExecutors . sameThreadExecutor ( ) ) ; initiatedStreams . put ( result . planId , result ) ; } public void registerReceiving ( final StreamResultFuture result ) { result . addEventListener ( notifier ) ; result . addListener ( new Runnable ( ) { public void run ( ) { receivingStreams . remove ( result . planId ) ; } } , MoreExecutors . sameThreadExecutor ( ) ) ; receivingStreams . put ( result . planId , result ) ; } public StreamResultFuture getReceivingStream ( UUID planId ) { return receivingStreams . get ( planId ) ; } public void addNotificationListener ( NotificationListener listener , NotificationFilter filter , Object handback ) { notifier . addNotificationListener ( listener , filter , handback ) ; } public void removeNotificationListener ( NotificationListener listener ) throws ListenerNotFoundException { notifier . removeNotificationListener ( listener ) ; } public void removeNotificationListener ( NotificationListener listener , NotificationFilter filter , Object handback ) throws ListenerNotFoundException { notifier . removeNotificationListener ( listener , filter , handback ) ; } public MBeanNotificationInfo [ ] getNotificationInfo ( ) { return notifier . getNotificationInfo ( ) ; } } 
