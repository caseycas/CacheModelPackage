require <str> require <str> require <str> require <str> class CSV VERSION = <str> class Row def initialize ( headers , fields , header_row = false ) @header_row = header_row headers . each { | h | h . freeze if h . is_a? String } @row = if headers . size > = fields . size headers . zip ( fields ) else fields . zip ( headers ) . map { | pair | pair . reverse! } end end attr_reader <str> protected <str> extend Forwardable def_delegators <str> , <str> , <str> , <str> def header_row? @header_row end def field_row? not header_row? end def headers @row . map { | pair | pair . first } end def field ( header_or_index , minimum_index = <int> ) finder = ( header_or_index . is_a? ( Integer ) || header_or_index . is_a? ( Range ) ) ? <str> : <str> pair = @row [ minimum_index .. - <int> ] . send ( finder , header_or_index ) if pair . nil? nil else header_or_index . is_a? ( Range ) ? pair . map ( & <str> ) : pair . last end end alias_method <str> , <str> def fetch ( header , * varargs ) raise ArgumentError , <str> if varargs . length > <int> pair = @row . assoc ( header ) if pair pair . last else if block_given? yield header elsif varargs . empty? raise KeyError , <str> header <str> else varargs . first end end end def has_key? ( header ) ! ! @row . assoc ( header ) end alias_method <str> , <str> alias_method <str> , <str> alias_method <str> , <str> def []= ( * args ) value = args . pop if args . first . is_a? Integer if @row [ args . first ] . nil? @row [ args . first ] = [ nil , value ] @row . map! { | pair | pair . nil? ? [ nil , nil ] : pair } else @row [ args . first ] [ <int> ] = value end else index = index ( * args ) if index . nil? self << [ args . first , value ] else @row [ index ] [ <int> ] = value end end end def << ( arg ) if arg . is_a? ( Array ) and arg . size == <int> @row << arg elsif arg . is_a? ( Hash ) arg . each { | pair | @row << pair } else @row << [ nil , arg ] end self end def push ( * args ) args . each { | arg | self << arg } self end def delete ( header_or_index , minimum_index = <int> ) if header_or_index . is_a? Integer @row . delete_at ( header_or_index ) elsif i = index ( header_or_index , minimum_index ) @row . delete_at ( i ) else [ ] end end def delete_if ( & block ) @row . delete_if ( & block ) self end def fields ( * headers_and_or_indices ) if headers_and_or_indices . empty? @row . map { | pair | pair . last } else headers_and_or_indices . inject ( Array . new ) do | all , h_or_i | all + if h_or_i . is_a? Range index_begin = h_or_i . begin . is_a? ( Integer ) ? h_or_i . begin : index ( h_or_i . begin ) index_end = h_or_i . end . is_a? ( Integer ) ? h_or_i . end : index ( h_or_i . end ) new_range = h_or_i . exclude_end? ? ( index_begin ... index_end ) : ( index_begin .. index_end ) fields . values_at ( new_range ) else [ field ( * Array ( h_or_i ) ) ] end end end end alias_method <str> , <str> def index ( header , minimum_index = <int> ) index = headers [ minimum_index .. - <int> ] . index ( header ) index . nil? ? nil : index + minimum_index end def header? ( name ) headers . include? name end alias_method <str> , <str> def field? ( data ) fields . include? data end include Enumerable def each ( & block ) @row . each ( & block ) self end def == ( other ) return @row == other . row if other . is_a? CSV :: Row @row == other end def to_hash Hash [ * @row . inject ( Array . new ) { | ary , pair | ary . push ( * pair ) } ] end def to_csv ( options = Hash . new ) fields . to_csv ( options ) end alias_method <str> , <str> def inspect str = [ <str> , self . class . to_s ] each do | header , field | str << <str> << ( header . is_a? ( Symbol ) ? header . to_s : header . inspect ) << <str> << field . inspect end str << <str> begin str . join ( <str> ) rescue str . map do | s | e = Encoding :: Converter . asciicompat_encoding ( s . encoding ) e ? s . encode ( e ) : s . force_encoding ( <str> ) end . join ( <str> ) end end end class Table def initialize ( array_of_rows ) @table = array_of_rows @mode = <str> end attr_reader <str> attr_reader <str> protected <str> extend Forwardable def_delegators <str> , <str> , <str> , <str> def by_col self . class . new ( @table . dup ) . by_col! end def by_col! @mode = <str> self end def by_col_or_row self . class . new ( @table . dup ) . by_col_or_row! end def by_col_or_row! @mode = <str> self end def by_row self . class . new ( @table . dup ) . by_row! end def by_row! @mode = <str> self end def headers if @table . empty? Array . new else @table . first . headers end end def [] ( index_or_header ) if @mode == <str> or ( @mode == <str> and ( index_or_header . is_a? ( Integer ) or index_or_header . is_a? ( Range ) ) ) @table [ index_or_header ] else @table . map { | row | row [ index_or_header ] } end end def []= ( index_or_header , value ) if @mode == <str> or ( @mode == <str> and index_or_header . is_a? Integer ) if value . is_a? Array @table [ index_or_header ] = Row . new ( headers , value ) else @table [ index_or_header ] = value end else if value . is_a? Array @table . each_with_index do | row , i | if row . header_row? row [ index_or_header ] = index_or_header else row [ index_or_header ] = value [ i ] end end else @table . each do | row | if row . header_row? row [ index_or_header ] = index_or_header else row [ index_or_header ] = value end end end end end def values_at ( * indices_or_headers ) if @mode == <str> or ( @mode == <str> and indices_or_headers . all? do | index | index . is_a? ( Integer ) or ( index . is_a? ( Range ) and index . first . is_a? ( Integer ) and index . last . is_a? ( Integer ) ) end ) @table . values_at ( * indices_or_headers ) else @table . map { | row | row . values_at ( * indices_or_headers ) } end end def << ( row_or_array ) if row_or_array . is_a? Array @table << Row . new ( headers , row_or_array ) else @table << row_or_array end self end def push ( * rows ) rows . each { | row | self << row } self end def delete ( index_or_header ) if @mode == <str> or ( @mode == <str> and index_or_header . is_a? Integer ) @table . delete_at ( index_or_header ) else @table . map { | row | row . delete ( index_or_header ) . last } end end def delete_if ( & block ) if @mode == <str> or @mode == <str> @table . delete_if ( & block ) else to_delete = Array . new headers . each_with_index do | header , i | to_delete << header if block [ [ header , self [ header ] ] ] end to_delete . map { | header | delete ( header ) } end self end include Enumerable def each ( & block ) if @mode == <str> headers . each { | header | block [ [ header , self [ header ] ] ] } else @table . each ( & block ) end self end def == ( other ) @table == other . table end def to_a @table . inject ( [ headers ] ) do | array , row | if row . header_row? array else array + [ row . fields ] end end end def to_csv ( options = Hash . new ) wh = options . fetch ( <str> , true ) @table . inject ( wh ? [ headers . to_csv ( options ) ] : [ ] ) do | rows , row | if row . header_row? rows else rows + [ row . fields . to_csv ( options ) ] end end . join ( <str> ) end alias_method <str> , <str> def inspect <str> self . class <str> @mode <str> to_a . size <str> . encode ( <str> ) end end class MalformedCSVError < RuntimeError ; end FieldInfo = Struct . new ( <str> , <str> , <str> ) DateMatcher = <str> DateTimeMatcher = <str> ConverterEncoding = Encoding . find ( <str> ) Converters = { <str> : lambda { | f | Integer ( f . encode ( ConverterEncoding ) ) rescue f } , <str> : lambda { | f | Float ( f . encode ( ConverterEncoding ) ) rescue f } , <str> : [ <str> , <str> ] , <str> : lambda { | f | begin e = f . encode ( ConverterEncoding ) e =~ DateMatcher ? Date . parse ( e ) : f rescue f end } , <str> : lambda { | f | begin e = f . encode ( ConverterEncoding ) e =~ DateTimeMatcher ? DateTime . parse ( e ) : f rescue f end } , <str> : [ <str> , <str> ] , } HeaderConverters = { <str> : lambda { | h | h . encode ( ConverterEncoding ) . downcase } , <str> : lambda { | h | h . encode ( ConverterEncoding ) . downcase . strip . gsub ( <str> , <str> ) . gsub ( <str> , <str> ) . to_sym } } DEFAULT_OPTIONS = { <str> : <str> , <str> : <str> , <str> : <str> , <str> : nil , <str> : nil , <str> : nil , <str> : false , <str> : false , <str> : nil , <str> : false , <str> : false , <str> : nil , <str> : false , } . freeze def self . instance ( data = $stdout , options = Hash . new ) sig = [ data . object_id ] + options . values_at ( * DEFAULT_OPTIONS . keys . sort_by { | sym | sym . to_s } ) @@instances || = Hash . new instance = ( @@instances [ sig ] || = new ( data , options ) ) if block_given? yield instance else instance end end def self . filter ( * args ) in_options , out_options = Hash . new , { <str> : $INPUT_RECORD_SEPARATOR } if args . last . is_a? Hash args . pop . each do | key , value | case key . to_s when <str> in_options [ $1 . to_sym ] = value when <str> out_options [ $1 . to_sym ] = value else in_options [ key ] = value out_options [ key ] = value end end end input = new ( args . shift || ARGF , in_options ) output = new ( args . shift || $stdout , out_options ) input . each do | row | yield row output << row end end def self . foreach ( path , options = Hash . new , & block ) return to_enum ( __method__ , path , options ) unless block open ( path , options ) do | csv | csv . each ( & block ) end end def self . generate ( * args ) if args . first . is_a? String io = StringIO . new ( args . shift ) io . seek ( <int> , IO :: SEEK_END ) args . unshift ( io ) else encoding = args [ - <int> ] [ <str> ] if args . last . is_a? ( Hash ) str = String . new str . force_encoding ( encoding ) if encoding args . unshift ( str ) end csv = new ( * args ) yield csv csv . string end def self . generate_line ( row , options = Hash . new ) options = { <str> : $INPUT_RECORD_SEPARATOR } . merge ( options ) encoding = options . delete ( <str> ) str = String . new if encoding str . force_encoding ( encoding ) elsif field = row . find { | f | not f . nil? } str . force_encoding ( String ( field ) . encoding ) end ( new ( str , options ) << row ) . string end def self . open ( * args ) options = if args . last . is_a? Hash then args . pop else Hash . new end file_opts = { <str> : false } . merge ( options ) begin f = File . open ( * args , file_opts ) rescue ArgumentError = > e raise unless <str> =~ e . message and args . size == <int> args << <str> file_opts = { <str> : Encoding . default_external } . merge ( file_opts ) retry end begin csv = new ( f , options ) rescue Exception f . close raise end if block_given? begin yield csv ensure csv . close end else csv end end def self . parse ( * args , & block ) csv = new ( * args ) if block . nil? begin csv . read ensure csv . close end else csv . each ( & block ) end end def self . parse_line ( line , options = Hash . new ) new ( line , options ) . shift end def self . read ( path , * options ) open ( path , * options ) { | csv | csv . read } end def self . readlines ( * args ) read ( * args ) end def self . table ( path , options = Hash . new ) read ( path , { <str> : true , <str> : <str> , <str> : <str> } . merge ( options ) ) end def initialize ( data , options = Hash . new ) if data . nil? raise ArgumentError . new ( <str> ) end options = DEFAULT_OPTIONS . merge ( options ) @io = data . is_a? ( String ) ? StringIO . new ( data ) : data @encoding = raw_encoding ( nil ) || ( if encoding = options . delete ( <str> ) case encoding when Encoding ; encoding else Encoding . find ( encoding ) end end ) || ( case encoding = options . delete ( <str> ) when Encoding ; encoding when <str> ; Encoding . find ( $& ) end ) || Encoding . default_internal || Encoding . default_external @re_esc = <str> . encode ( @encoding ) . freeze rescue <str> @re_chars = <str> . encode ( @encoding ) <str> init_separators ( options ) init_parsers ( options ) init_converters ( options ) init_headers ( options ) init_comments ( options ) @force_encoding = ! ! ( encoding || options . delete ( <str> ) ) options . delete ( <str> ) options . delete ( <str> ) unless options . empty? raise ArgumentError , <str> options . keys . join ( <str> ) <str> end @lineno = <int> end attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> attr_reader <str> def converters @converters . map do | converter | name = Converters . rassoc ( converter ) name ? name . first : converter end end def unconverted_fields? ( ) @unconverted_fields end def headers @headers || true if @use_headers end def return_headers? ( ) @return_headers end def write_headers? ( ) @write_headers end def header_converters @header_converters . map do | converter | name = HeaderConverters . rassoc ( converter ) name ? name . first : converter end end def skip_blanks? ( ) @skip_blanks end def force_quotes? ( ) @force_quotes end def liberal_parsing? ( ) @liberal_parsing end attr_reader <str> attr_reader <str> extend Forwardable def_delegators <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> , <str> = , <str> , <str> , <str> , <str> , <str> , <str> = , <str> , <str> , <str> , <str> , <str> def rewind @headers = nil @lineno = <int> @io . rewind end def << ( row ) if header_row? and [ Array , String ] . include? @use_headers . class parse_headers self << @headers if @write_headers end row = case row when self . class :: Row then row . fields when Hash then @headers . map { | header | row [ header ] } else row end @headers = row if header_row? @lineno += <int> output = row . map ( & @quote ) . join ( @col_sep ) + @row_sep if @io . is_a? ( StringIO ) and output . encoding != ( encoding = raw_encoding ) if @force_encoding output = output . encode ( encoding ) elsif ( compatible_encoding = Encoding . compatible? ( @io . string , output ) ) @io . set_encoding ( compatible_encoding ) @io . seek ( <int> , IO :: SEEK_END ) end end @io << output self end alias_method <str> , <str> alias_method <str> , <str> def convert ( name = nil , & converter ) add_converter ( <str> , self . class :: Converters , name , & converter ) end def header_convert ( name = nil , & converter ) add_converter ( <str> , self . class :: HeaderConverters , name , & converter ) end include Enumerable def each if block_given? while row = shift yield row end else to_enum end end def read rows = to_a if @use_headers Table . new ( rows ) else rows end end alias_method <str> , <str> def header_row? @use_headers and @headers . nil? end def shift if header_row? and @return_headers and [ Array , String ] . include? @use_headers . class if @unconverted_fields return add_unconverted_fields ( parse_headers , Array . new ) else return parse_headers end end in_extended_col = false csv = Array . new loop do unless parse = @io . gets ( @row_sep ) return nil end parse . sub! ( @parsers [ <str> ] , <str> ) if csv . empty? if parse . empty? @lineno += <int> if @skip_blanks next elsif @unconverted_fields return add_unconverted_fields ( Array . new , Array . new ) elsif @use_headers return self . class :: Row . new ( Array . new , Array . new ) else return Array . new end end end next if @skip_lines and @skip_lines . match parse parts = parse . split ( @col_sep , - <int> ) if parts . empty? if in_extended_col csv [ - <int> ] << @col_sep else csv << nil end end parts . each do | part | if in_extended_col if part [ - <int> ] == @quote_char && part . count ( @quote_char ) % <int> != <int> csv . last << part [ <int> .. - <int> ] if csv . last =~ @parsers [ <str> ] raise MalformedCSVError , <str> lineno + <int> <str> end csv . last . gsub! ( @quote_char * <int> , @quote_char ) in_extended_col = false else csv . last << part csv . last << @col_sep end elsif part [ <int> ] == @quote_char if part . count ( @quote_char ) % <int> != <int> csv << part [ <int> .. - <int> ] csv . last << @col_sep in_extended_col = true elsif part [ - <int> ] == @quote_char csv << part [ <int> .. - <int> ] if csv . last =~ @parsers [ <str> ] raise MalformedCSVError , <str> lineno + <int> <str> end csv . last . gsub! ( @quote_char * <int> , @quote_char ) elsif @liberal_parsing csv << part else raise MalformedCSVError , <str> lineno + <int> <str> end elsif part =~ @parsers [ <str> ] if part =~ @parsers [ <str> ] raise MalformedCSVError , <str> + <str> lineno + <int> <str> else if @liberal_parsing csv << part else raise MalformedCSVError , <str> lineno + <int> <str> end end else csv << ( part . empty? ? nil : part ) end end csv [ - <int> ] [ - <int> ] = @row_sep if in_extended_col if in_extended_col if @io . eof? raise MalformedCSVError , <str> lineno + <int> <str> elsif @field_size_limit and csv . last . size > = @field_size_limit raise MalformedCSVError , <str> lineno + <int> <str> end else @lineno += <int> unconverted = csv . dup if @unconverted_fields csv = convert_fields ( csv ) unless @use_headers or @converters . empty? csv = parse_headers ( csv ) if @use_headers if @unconverted_fields and not csv . respond_to? <str> add_unconverted_fields ( csv , unconverted ) end break csv end end end alias_method <str> , <str> alias_method <str> , <str> def inspect str = [ <str> , self . class . to_s , <str> ] if @io == $stdout then str << <str> elsif @io == $stdin then str << <str> elsif @io == $stderr then str << <str> else str << @io . class . to_s end if @io . respond_to? ( <str> ) and ( p = @io . path ) str << <str> << p . inspect end str << <str> << @encoding . name <str> . each do | attr_name | if a = instance_variable_get ( <str> attr_name <str> ) str << <str> << attr_name << <str> << a . inspect end end if @use_headers str << <str> << headers . inspect end str << <str> begin str . join ( <str> ) rescue str . map do | s | e = Encoding :: Converter . asciicompat_encoding ( s . encoding ) e ? s . encode ( e ) : s . force_encoding ( <str> ) end . join ( <str> ) end end private def init_separators ( options ) @col_sep = options . delete ( <str> ) . to_s . encode ( @encoding ) @row_sep = options . delete ( <str> ) @quote_char = options . delete ( <str> ) . to_s . encode ( @encoding ) if @quote_char . length != <int> raise ArgumentError , <str> end if @row_sep == <str> if [ ARGF , STDIN , STDOUT , STDERR ] . include? ( @io ) or ( defined? ( Zlib ) and @io . class == Zlib :: GzipWriter ) @row_sep = $INPUT_RECORD_SEPARATOR else begin saved_pos = @io . pos while @row_sep == <str> break unless sample = @io . gets ( nil , <int> ) if sample . end_with? encode_str ( <str> ) sample << ( @io . gets ( nil , <int> ) || <str> ) end if sample =~ encode_re ( <str> ) @row_sep = $& break end end @io . rewind while saved_pos > <int> @io . read ( <int> ) saved_pos -= <int> end @io . read ( saved_pos ) if saved_pos . nonzero? rescue IOError rescue NoMethodError rescue SystemCallError ensure @row_sep = $INPUT_RECORD_SEPARATOR if @row_sep == <str> end end end @row_sep = @row_sep . to_s . encode ( @encoding ) @force_quotes = options . delete ( <str> ) do_quote = lambda do | field | field = String ( field ) encoded_quote = @quote_char . encode ( field . encoding ) encoded_quote + field . gsub ( encoded_quote , encoded_quote * <int> ) + encoded_quote end quotable_chars = encode_str ( <str> , @col_sep , @quote_char ) @quote = if @force_quotes do_quote else lambda do | field | if field . nil? <str> else field = String ( field ) if field . empty? or field . count ( quotable_chars ) . nonzero? do_quote . call ( field ) else field end end end end end def init_parsers ( options ) @skip_blanks = options . delete ( <str> ) @field_size_limit = options . delete ( <str> ) @liberal_parsing = options . delete ( <str> ) esc_row_sep = escape_re ( @row_sep ) esc_quote = escape_re ( @quote_char ) @parsers = { <str> : encode_re ( <str> , esc_quote , <str> ) , <str> : encode_re ( <str> ) , <str> : encode_re ( <str> , esc_quote , <str> , esc_quote , <str> , esc_quote , <str> ) , <str> : encode_re ( esc_row_sep , <str> ) , <str> : encode_str ( <str> ) } end def init_converters ( options , field_name = <str> ) if field_name == <str> @unconverted_fields = options . delete ( <str> ) end instance_variable_set ( <str> field_name <str> , Array . new ) convert = method ( field_name . to_s . sub ( <str> , <str> ) ) unless options [ field_name ] . nil? unless options [ field_name ] . is_a? Array options [ field_name ] = [ options [ field_name ] ] end options [ field_name ] . each do | converter | if converter . is_a? Proc convert . call ( & converter ) else convert . call ( converter ) end end end options . delete ( field_name ) end def init_headers ( options ) @use_headers = options . delete ( <str> ) @return_headers = options . delete ( <str> ) @write_headers = options . delete ( <str> ) @headers = nil init_converters ( options , <str> ) end def init_comments ( options ) @skip_lines = options . delete ( <str> ) @skip_lines = Regexp . new ( @skip_lines ) if @skip_lines . is_a? String if @skip_lines and not @skip_lines . respond_to? ( <str> ) raise ArgumentError , <str> end end def add_converter ( var_name , const , name = nil , & converter ) if name . nil? instance_variable_get ( <str> var_name <str> ) << converter else combo = const [ name ] case combo when Array combo . each do | converter_name | add_converter ( var_name , const , converter_name ) end else instance_variable_get ( <str> var_name <str> ) << combo end end end def convert_fields ( fields , headers = false ) converters = headers ? @header_converters : @converters fields . map . with_index do | field , index | converters . each do | converter | break if field . nil? field = if converter . arity == <int> converter [ field ] else header = @use_headers && ! headers ? @headers [ index ] : nil converter [ field , FieldInfo . new ( index , lineno , header ) ] end break unless field . is_a? String end field end end def parse_headers ( row = nil ) if @headers . nil? @headers = case @use_headers when Array then @use_headers when String self . class . parse_line ( @use_headers , <str> : @col_sep , <str> : @row_sep , <str> : @quote_char ) else row end row = @headers if row . nil? @headers = convert_fields ( @headers , true ) @headers . each { | h | h . freeze if h . is_a? String } if @return_headers return self . class :: Row . new ( @headers , row , true ) elsif not [ Array , String ] . include? @use_headers . class return shift end end self . class :: Row . new ( @headers , convert_fields ( row ) ) end def add_unconverted_fields ( row , fields ) class << row attr_reader <str> end row . instance_eval { @unconverted_fields = fields } row end def escape_re ( str ) str . gsub ( @re_chars ) { | c | @re_esc + c } end def encode_re ( * chunks ) Regexp . new ( encode_str ( * chunks ) ) end def encode_str ( * chunks ) chunks . map { | chunk | chunk . encode ( @encoding . name ) } . join ( <str> ) end private def raw_encoding ( default = Encoding :: ASCII_8BIT ) if @io . respond_to? <str> @io . internal_encoding || @io . external_encoding elsif @io . is_a? StringIO @io . string . encoding elsif @io . respond_to? <str> @io . encoding else default end end end def CSV ( * args , & block ) CSV . instance ( * args , & block ) end class Array def to_csv ( options = Hash . new ) CSV . generate_line ( self , options ) end end class String def parse_csv ( options = Hash . new ) CSV . parse_line ( self , options ) end end 
