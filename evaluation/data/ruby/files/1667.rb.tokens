require <str> module TkSelection include Tk extend Tk TkCommandNames = [ <str> . freeze ] . freeze def self . clear ( sel = nil ) if sel tk_call_without_enc ( <str> , <str> , <str> , sel ) else tk_call_without_enc ( <str> , <str> ) end end def self . clear_on_display ( win , sel = nil ) if sel tk_call_without_enc ( <str> , <str> , <str> , win , <str> , sel ) else tk_call_without_enc ( <str> , <str> , <str> , win ) end end def clear ( sel = nil ) TkSelection . clear_on_display ( self , sel ) self end def self . get ( keys = nil ) _fromUTF8 ( tk_call_without_enc ( <str> , <str> , * hash_kv ( keys ) ) ) end def self . get_on_display ( win , keys = nil ) _fromUTF8 ( tk_call_without_enc ( <str> , <str> , <str> , win , * hash_kv ( keys ) ) ) end def get ( keys = nil ) TkSelection . get_on_display ( self , sel ) end def self . handle ( win , func = Proc . new , keys = nil , & b ) if func . kind_of? ( Hash ) && keys == nil keys = func func = Proc . new ( & b ) end args = [ <str> , <str> ] args . concat ( hash_kv ( keys ) ) args . concat ( [ win , func ] ) tk_call_without_enc ( * args ) end def handle ( func = Proc . new , keys = nil , & b ) TkSelection . handle ( self , func , keys , & b ) end def self . get_owner ( sel = nil ) if sel window ( tk_call_without_enc ( <str> , <str> , <str> , sel ) ) else window ( tk_call_without_enc ( <str> , <str> ) ) end end def self . get_owner_on_display ( win , sel = nil ) if sel window ( tk_call_without_enc ( <str> , <str> , <str> , win , <str> , sel ) ) else window ( tk_call_without_enc ( <str> , <str> , <str> , win ) ) end end def get_owner ( sel = nil ) TkSelection . get_owner_on_display ( self , sel ) self end def self . set_owner ( win , keys = nil ) tk_call_without_enc ( <str> , <str> , * ( hash_kv ( keys ) << win ) ) end def set_owner ( keys = nil ) TkSelection . set_owner ( self , keys ) self end end 
