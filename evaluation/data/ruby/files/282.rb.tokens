module Network class Graph attr_reader <str> , <str> , <str> , <str> , <str> def self . max_count @max_count || = <int> end def initialize ( project , ref , commit , filter_ref ) @project = project @ref = ref @commit = commit @filter_ref = filter_ref @repo = project . repository @commits = collect_commits @days = index_commits @notes = collect_notes end protected def collect_notes h = Hash . new ( <int> ) @project . notes . where ( <str> , <str> ) . group ( <str> ) . select ( <str> ) . each do | item | h [ item . commit_id ] = item . note_count . to_i end h end def collect_commits find_commits ( count_to_display_commit_in_center ) . map do | commit | Network :: Commit . new ( commit ) end end def index_commits days = [ ] @map = { } @reserved = { } @commits . each_with_index do | c , i | c . time = i days [ i ] = c . committed_date @map [ c . id ] = c @reserved [ i ] = [ ] end commits_sort_by_ref . each do | commit | place_chain ( commit ) end @commits . each do | c | c . parent_spaces . concat ( find_free_parent_spaces ( c ) ) end days end def count_to_display_commit_in_center offset = - <int> skip = <int> while offset == - <int> tmp_commits = find_commits ( skip ) if tmp_commits . size > <int> index = tmp_commits . index do | c | c . id == @commit . id end if index offset = index + skip else skip += self . class . max_count end else offset = <int> end end if self . class . max_count / <int> < offset then offset - self . class . max_count / <int> else <int> end end def find_commits ( skip = <int> ) opts = { <str> : self . class . max_count , <str> : skip } opts [ <str> ] = @commit . id if @filter_ref @repo . find_commits ( opts ) end def commits_sort_by_ref @commits . sort do | a , b | if include_ref? ( a ) - <int> elsif include_ref? ( b ) <int> else b . committed_date < = > a . committed_date end end end def include_ref? ( commit ) commit . ref_names ( @repo ) . include? ( @ref ) end def find_free_parent_spaces ( commit ) spaces = [ ] commit . parents ( @map ) . each do | parent | range = commit . time .. parent . time space = if commit . space > = parent . space then find_free_parent_space ( range , parent . space , - <int> , commit . space ) else find_free_parent_space ( range , commit . space , - <int> , parent . space ) end mark_reserved ( range , space ) spaces << space end spaces end def find_free_parent_space ( range , space_base , space_step , space_default ) if is_overlap? ( range , space_default ) then find_free_space ( range , space_step , space_base , space_default ) else space_default end end def is_overlap? ( range , overlap_space ) range . each do | i | if i != range . first && i != range . last && @commits [ i ] . spaces . include? ( overlap_space ) then return true ; end end false end def place_chain ( commit , parent_time = nil ) leaves = take_left_leaves ( commit ) if leaves . empty? return end time_range = leaves . first . time .. leaves . last . time space_base = get_space_base ( leaves ) space = find_free_space ( time_range , <int> , space_base ) leaves . each do | l | l . spaces << space end if parent_time . nil? min_time = leaves . first . time else min_time = parent_time + <int> end max_time = leaves . last . time leaves . last . parents ( @map ) . each do | parent | if max_time < parent . time max_time = parent . time end end mark_reserved ( min_time .. max_time , space ) leaves . each do | l | parents = l . parents ( @map ) . select { | p | p . space . zero? } for p in parents place_chain ( p , l . time ) end end end def get_space_base ( leaves ) space_base = <int> parents = leaves . last . parents ( @map ) if parents . size > <int> if parents . first . space > <int> space_base = parents . first . space end end space_base end def mark_reserved ( time_range , space ) for day in time_range @reserved [ day ] . push ( space ) end end def find_free_space ( time_range , space_step , space_base = <int> , space_default = nil ) space_default || = space_base reserved = [ ] for day in time_range reserved . push ( * @reserved [ day ] ) end reserved . uniq! space = space_default while reserved . include? ( space ) do space += space_step if space < space_base then space_step *= - <int> space = space_base + space_step end end space end def take_left_leaves ( raw_commit ) commit = @map [ raw_commit . id ] leaves = [ ] leaves . push ( commit ) if commit . space . zero? while true return leaves if commit . parents ( @map ) . count . zero? commit = commit . parents ( @map ) . first return leaves unless commit . space . zero? leaves . push ( commit ) end end end end 
